## Дизайн контроллеров

Когда речь заходит о дизайне контроллеров, я рекомендую создавать небольшие классы контроллеров. Прежде всего это
означает группировку логически связанных действий в одном классе контроллера, а также создание небольших методов для
действий, которые не содержат в себе тяжеловесной логики и максимум два возможных пути исполнения. Это, в свою
очередь означает, что в конце концов у вас будет много разных контроллеров, однако же этот подход имеет много 
преимуществ, которые также связаны и с безопасностью:

1. Когда вам нужно изменить какое-то, связанное с пользователем, поведение, вы можете очень быстро найти путь к 
контроллеру по URL и имени маршрута.
2. Когда некоторые контроллеры будут требовать повышенного внимания с точки зрения безопасности, вы легко можете
определить их и концентрировать защитную логику в одном месте.

Для иллюстрации второго утверждения приведу пример. Положим, у вас есть контроллер, имеющий отношение к персональным
настройкам пользователя, но он зависит как от строго конфиденциальных данных, таких как информация о счёте, платёжной
информации (номера кредитных карт), так и от публично доступных, таких как никнейм или аватар. Я рекомендую разделять 
страницы, относящиеся к просмотру и редактированию этих данных по разным котроллерам, наделяя их простыми и понятными 
именами. Внутри контроллеров каждое действие также должно иметь понятное имя, которое может быть длиннее, чем те, 
к которым вы привыкли, например AccountController::editAccountInformation (вместо короткого "edit") и 
PaymentController::listCreditCards. Это позволит вам уровнять ваш уровень бдительности с уровнем, необходимым для
конкретного кода, над которым выработаете (@dbykadorov: мне кажется, Маттиас имеет в виду, что Foo:edit и Bar:list
не отражают реальной важности выполняемого действия, а в предлагаемой им нотации взгляд сразу зацепится за 
editAccountInfomation или listCreditCards).

Более того, при взгляде на код сразу должно быть понятно, какой контроллер используется для модификации
состояния приложения (например, сохранения или удаления данных). Вы должны явно указывать HTTP методы, разрешённые для
действий. В этом смысле, страницы, которые могут быть запрошены с помощью метода GET - безобидные, а страницы, на 
которых пользователи могут выполнять POST запросы, таковыми не являются.

```php
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;

/**
 * @Method("GET")
 */
public function viewPublicProfileAction()
{
}

/**
 * @Method("GET")
 */
public function editPublicProfileAction()
{
}

/**
 * @Method("POST")
 */
public function updatePublicProfileAction()
{
}
```

И, конечно же, заведомо нехорошо, когда кто-то может видеть форму редактирования некоего объекта, в том случае, 
когда к этому объекту он не имеет необходимых прав доступа. И ещё хуже, когда он может реально изменить его.

### Защита действий в контроллерах

Имеется немало способов, при помощи которых вы можете защитить действия. Код действия сам по себе иногда может
генерировать исключение AccessDeniedException, и, конечно же, вы должны проверять, что конкретный объект принадлежит
кому-то конкретному или может быть им модифицирован (либо на основании того, что владелец хранится как свойство 
объекта, либо на основании того, что права доступа регистрируются с помощью ACL). Но вы также должны каким-либо 
образом реализовать управление ролями. Использовать роли в Symfony очень легко. Только подумайте о новой роли - и вот,
она уже существует. Когда существующие роли должны включать в себя новую роль, добавьте её в т.н. "иерархию ролей" в
security.yml.

Очень важно начать составлять список ролей для любого контроллера, который требует, чтобы пользователь вошёл в
приложение. И для этого несколько (хороших) причин. Во-первых, когда речь идет о безопасности, вы должны
придерживаться принципа "наименьших привилегий". Это означает, что по умолчанию аутентифицированный пользователь
не может делать ровным счётом ничего (ну может быть может изменить свой пароль...). Вы, система или администратор
могут предоставить ему некоторые дополнительные права. Вы можете использовать все виды выражений, касающиеся ролей
в действиях, используя аннотацию @PreAuthorize, но в большинстве ситуаций, с которыми я столкнулся, достаточно
просто воспользоваться аннотацией @Secure:

```php
use JMS\SecurityExtraBundle\Annotation\Secure;

/**
 * @Secure("ROLE_PAGE_EDITOR")
 */
public function editPageAction()
{
}
```

Часто случается так, что разные типы пользователей должны иметь доступ к странице editPageAction, например,
пользователь с ролью ROLE_ADMINISTRATOR, а также кто-то с ролью ROLE_CONTENT_MANAGER. Решением в данном случае
будет не добавление дополнительных ролей в аннотацию @Secure (таким образом - 
`@Secure({"ROLE_ADMINISTRATOR", "ROLE_CONTENT_MANAGER"})`), а доработка иерархии ролей следующим образом:

```yml
security:
    role_hierarchy:
        ROLE_ADMINISTRATOR: [ROLE_PAGE_EDITOR]
        ROLE_CONTENT_MANAGER: [ROLE_PAGE_EDITOR]
```

Когда речь идёт о ролях, запомните:

- Роли не константны: вы вольны добавлять новые и (почти) вольны удалять их (по сути это просто строки)
- Роли работают лучше, если роль описывает пользователя, которому будет назначена эта роль (имен ролей в идеале
должны оканчиваться на "MANAGER", "EDITOR", "MODERATOR, и т.д. и т.п.).

### Размещение контроллеров за файрволлом

Теперь представьте, что у вас есть много контроллеров в каком-то бандле, например, SettingsBundle. Теперь вам нужно
импортировать их все в файл routing.yml в этом бандле:

```yml
SettingsBundleControllers:
    resource: "@SettingsBundle/Controller/"
    type: annotation
```

Этот файл может быть импортирован разом в файле routing.yml, принадлежащему приложению (`app/config/routing.yml`). 
Это позволит вам определить префикс для всех маршрутов из SettingsBundle:

```yml
SettingsBundle:
    resource: "@SettingsBundle/Resources/config/routing.yml"
    type: yaml
    prefix: /settings
```

Используя этот префикс, вы можете с лёгкостью определять множество ролей, необходимых для любого URI, который 
начинается с `/settings`:

```yml
security:
    access_control:
        - { path: ^/settings, roles: [IS_AUTHENTICATED_FULLY] }
```

Конфигурация выше означает, что вам необходимо быть полностью аутентифицированными, для того, чтобы выполнить 
любое действие, относящееся к настройкам (если вы вошли при помощи куки "remember me", это также не даст вам
необходимых прав доступа). Это хороший приём и у вас теперь есть единая точка для контроля безопасности.
