## Когда стоит использовать аннотации

При помощи аннотаций вы можете делать всё что угодно, но в моей практике встречалось лишь несколько типов ситуаций, когда стоит использовать аннотации.

### Загрузка конфигураций

Часто аннотации используются для загрузки статической конфигурации для классов. Вот несколько хороших примеров
библиотек, которые используют аннотации таким образом:

- [Doctrine ORM](https://github.com/doctrine/doctrine2) - маппинг сущностей на таблицы в базе данных.
- [Symfony Routing Component](https://github.com/symfony/routing) - конфигурирование маршрутов в классах контроллеров.
- [Symfony Validator Component](https://github.com/symfony/validator) - добавление правил валидации для классов.
- [JMS Serializer](https://github.com/schmittjoh/serializer) - настройка параметров сериализации для любых классов.

Во всех этих библиотеках аннотации используются лишь как источник настроек. Все они предлагают также другие эквивалентные способы выполнить те же настройки, например загрузить некоторые XML, Yaml или PHP файлы конфигурации. Результат загрузки конфигурации при помощи любого из этих ресурсов будет использован для выполнения одних и тех же функций (создания схемы БД, валидации или сериализации объекта, генерации маршрута и т.д.). В данном случае аннотации, используемые для загрузки конфигурации не являются чем-то особенным и незаменимым - они лишь предоставляют одну из возможных альтернатив.

Важной характеристикой всех этих библиотек, которые используют аннотации для описания конфигурации, является то, что они парсят соответствующие аннотации единожды и комбинируют результаты с данными, полученными из других источников. Полученные в итоге данные кэшируются с целью сделать их повторное использование более быстрым. После первого запуска уже не имеет значения как были получены эти значения - из XML файлов, аннотаций или ещё откуда. Данные были скомбинированы и объединены в единый формат.

> #### Аннотации и связность кода
>
> Некоторые разработчики жалуются, что аннотации увеличивают связность классов. На практике существуют как аргументы за, так и против этой позиции: аннотации можно рассматривать как "всего-лишь комментарии" и с этой точки зрения они абсолютно не увеличивают связность классов, так как этот показатель учитывает как классы (а не их комментарии) связаны между собой. Тем не менее, после того как докблок распарсен, аннотации ставятся в соответствие классам. И в этом смысле ваш класс становится связанным с классом аннотации, которую он использует.
>
> Этот особый тип связности становится весьма заметным, когда у вас есть класс, который использует несколько типов аннотаций, например Doctrine ORM и JMS Serializer:
> 
> ```php
> use JMS\Serializer\Annotation as Serialize;
> use Doctrine\ORM\Mapping as ORM:
> 
> class Something
> {
>     /**
>      * @ORM\Column(type="string")
>      * @Serialize\Type("string")
>      */
>     private $property;
> }
> ```
> 
> Положим, проект, в котором вы хотите использовать этот класс, не имеет JMS Serializer'а среди зависимостей, но имеет Doctrine ORM и вы хотите использовать метаданные маппинга для того, чтобы иметь возможность хранить экземпляры класса Something в вашей реляционной базе данных. И вот, как только Doctrine начнёт считывать аннотации - она тут же выдаст ошибку:
> 
> ```
> [Semantical Error] The annotation "@Serialize\Type" in [...] does not
> exist, or could not be auto-loaded.
> ```
> 
> Эта ошибка является явным указанием на то, что класс Something на самом деле тесно связан со своими аннотациями. Ошибки типа этой являются аргументом против использования аннотаций в классах, если вы хотите их повторно использовать в дальнейшем, так как вне вашего проекта, шансы на то, что вы будете получать ошибки, используя классы с аннотациями, из за отсутствующих зависимостей - весьма велики.
> 
> Использование аннотаций в классах, которые используются только внутри вашего проекта, лично для меня является более чем приемлемым (это уже обсуждалось в другой главе этой книги - [Соглашения по конфигурированию](#configuration-conventions)). Связность классов с аннотациям в данном случае не будет иметь никакого значения, так как классы приложения не будут использоваться в другом контексте.

### Контроль процесса выполнения приложения

Вместо того, чтобы быть распарсеными лишь однажды, в виде части конфигурации, аннотации могут также быть использованы для влияния на процесс выполнения приложений. Наилучшим примером такого использования аннотаций является [SensioFrameworkExtraBundle](https://github.com/sensiolabs/SensioFrameworkExtraBundle), который включает в себя аннотации, контролирующие процесс генерации ядром HttpKernel ответа на конкретный запрос. Как было рассмотрено в первой главе этой книги, в ходе процесса генерации ответа имеется много мест, где слушатели событий имеют возможность изменить результат. Бандл SensioFrameworkExtraBundle содержит много различных слушателей, которые модифицируют объект Response, создают его, если он не был создан в контроллере, а также модифицируют полученный объект ответа, на основании аннотаций, которые были указаны в докблоке контроллера.

Например вы можете использовать аннотацию [@Template annotation](http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/view.html) над методом действия в классе контроллера, для того, чтобы указать, что результат выполнения этого действия должен быть использован в качестве переменных шаблона:

```php
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;

class UserController
{
    /**
     * @Template("MatthiasAdminBundle:User:edit.html.twig")
     */
    public function editAction(User $user)
    {
        return array(
            'user' => $user,
        );
    }
}
```

Для того чтобы эта аннотация работала, SensioFrameworkExtraBundle регистрирует слушатель, который перехватывает событие kernel.controller и получает аннотацию @Template для текущего контроллера. Затем он (слушатель) пытается определить, какой шаблон должен быть отрендерен и сохраняет имя файла шаблона в атрибут запроса _template. Когда контроллер был выполнен и вернул что-то отличное от объекта Response, другой слушатель перехватывает событие kernel.view и рендерит шаблон, указанный в атрибуте запроса _template, используя значение, которое вернул контроллер в качестве переменных шаблона (как правило, на выходе ожидается массив с переменными шаблона).
