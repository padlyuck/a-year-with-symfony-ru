## Валидация входных данных

Любые входные данные, поступающие в ваше приложение извне, должны быть проверены и обработаны, прежде
чем они будут реально использоваться или же будут сохранены тем или иным образом.

### Безопасные формы

Symfony включает в себя два важных инструмента, которые вы можете использовать в борьбе за
безопасные входные данные: это компоненты Form и Validator. Большинство Symfony разработчиков
уже доверили свои "жизни" компоненту форм:

{lang="php"}
~~~~~~~~~~~~
if ($request->isMethod('POST')) {
    $form->bind($request);
    if ($form->isValid()) {
        // persist!
    }
}
~~~~~~~~~~~~

И это доверие вполне обосновано, так как компоненты Form и Validator сами по себе классные и им можно доверить
безопасность ваших форм. Но, вы не обязаны им слепо доверяться - в вопросах безопасности доверять "на слово" ничему
нельзя. Ниже мы разберём как обрести уверенность, работая с этими двумя компонентами.

#### HTML5-валидация

Мысленно возвращаясь к временам, когда мы писали наши PHP приложения вручную от начала до конца, уже тогда
нам нужно было заниматься валидацией данных форм. Например, если мы не хотели, чтобы пользователи оставляли пустым 
поле "name", нужно было после отправки формы проверить присланное значение и вывести сообщение об ошибке, 
если поле не было заполнено. Сейчас же, когда мы собираем Symfony-форму из полей (которые, в терминах компонента,
формально тоже являются формами) нам достаточно установить для поля свойство "required" в "true". Когда
мы откроем нашу форму в браузере и попробуем отправить её не заполняя, вы увидите красивое сообщение об ошибке
(которое является особенностью HTML5) и форма не будет отправлена, пока обязательные значения не будут заполнены.
Тем не менее, если вы отключите клиентскую HTML5-валидацию, добавив атрибут "novalidate" в таг формы, вы 
увидите, что по умолчанию серверной валидации у нашей формы нет. Таким образом, первым делом при создании любой формы
вам необходимо (возможно только для DEV окружения) отключить HTML5 валидацию:

{lang="html"}
~~~~~~~~~~~~~
<form{% if app.debug %} novalidate="true"{% endif %}>
~~~~~~~~~~~~~

Теперь вы можете тестировать серверную валидацию ваших форм.

> @dbykadorov: пользуясь правом переводчика, хочу отметить, что я не люблю использовать HTML5-валидациию
> и рекомендую ВСЕГДА отключать её для ВСЕХ форм сразу при их создании (а не только в DEV окружении). Как 
> отметил выше Маттиас, по умолчанию в формах имеется минимум валидации и нужно всегда опираться на те 
> правила, которые вы принудительно определите для вашей формы.

#### Ограничения валидатора

Как правило, у вас имеется некий доменный объект, назовём его сущностью, который вам нужно создать или 
модифицировать при помощи формы. В этом случае вам необходимо указать имя класса этой сущности в опции
"data_class" соответствующей формы. В методе класса формы buildForm при помощи экземпляра класса FormBuilder 
вы можете добавить поля, соответствующие атрибутам сущности. Теперь, для того, чтобы выполнить валидацию
данных формы, вам необходимо добавить ограничения к этим атрибутам (для этого удобно использовать аннотации).
Этот процесс [очень хорошо описан](http://symfony.com/doc/master/book/forms.html) в официальной документации.

{lang="php"}
~~~~~~~~~~~~
namespace Matthias\AccountBundle\Entity;

use Symfony\Component\Validator\Constraints as Assert;

class User
{
    /**
     * @Assert\Email()
     * @Assert\NotBlank()
     */
    private $emailAddress;
}
~~~~~~~~~~~~

> #### Пользовательские ограничения валидации
> 
> Порой стандартных ограничений валидатора, включенных в компонент Symfony Validator Component, 
> бывает недостаточно для проверки ваших данных. Но не отчаивайтесь, просто создайте 
> [ваше собственное ограничение валидации](http://symfony.com/doc/current/cookbook/validation/custom_constraint.html)
> и соответствующий валидатор.

#### Формы без сущности

Если у вас есть данные, которые не соотносятся один к одному с какой-либо сущностью, в этому случае документация 
предлагает не использовать класс данных и, фактически, создавать форму сразу в контроллере:

{lang="php"}
~~~~~~~~~~~~
public function contactAction(Request $request)
{
    $defaultData = array('message' => 'Type your message here');
    $form = $this->createFormBuilder($defaultData)
        ->add('name', 'text')
        ->add('email', 'email')
        ->add('message', 'textarea')
        ->getForm();

    $form->handleRequest($request);

    if ($form->isValid()) {
        // $data тут будует представлен в виде массива с ключами "name", "email", и "message"
        $data = $form->getData();
    }
}
~~~~~~~~~~~~

Для меня этот звучит как плохая идея по двум причинам: во-первых, вы всегда должны определять формы при помощи
соответствующих классов, наследуемых от AbstractType, например так:

{lang="php"}
~~~~~~~~~~~~
use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;

class ContactFormType extends AbstractType
{
    public function buildForm(
        FormBuilderInterface $builder,
        array $options
    ) {
        $builder
            ->add('name', 'text')
            ->add('email', 'email')
            ->add('message', 'textarea')
        ;
    }

    public function getName()
    {
        return 'contact_form';
    }
}
~~~~~~~~~~~~

Такой подход позволит поместить логику, относящуюся к форме, в одном месте, что сделает возможным её повторное 
использование и упростит обслуживание.

Во-вторых, вы всегда должны указывать в классе формы её data_class. Контактная форма выше может и не сохраняться
в базу данных, но всё же она имеет определенную монолитную структуру и вполне определённое назначение. В этом
случае нужно выбрать подходящее наименование для объекта, который будет содержать данные этой формы, например,
ContactDetails, создать класс с требуемыми полями и добавить ограничения для каждого поля, чтобы можно было
убедиться в консистентности данных:

{lang="php"}
~~~~~~~~~~~~
use Symfony\Component\Validator\Constraints as Assert;

class ContactDetails
{
    /**
     * @Assert\NotBlank
     */
    private $name;

    /**
     * @Assert\NotBlank
     * @Assert\Email
     */
    private $email;

    /**
     * @Assert\NotBlank
     */
    private $message;

    // также добавьте get- и set-методы для каждого поля
}
~~~~~~~~~~~~

Теперь можно указать этот класс в опции data_class формы ContactFormType:

{lang="php"}
~~~~~~~~~~~~
use Symfony\Component\OptionsResolver\OptionsResolverInterface;

class ContactFormType extends AbstractType
{
    public function setDefaultOptions(OptionsResolverInterface $resolver)
    {
        $resolver->setDefaults(array(
            'data_class' => 'LifeOnline\ContactBundle\Model\ContactDetails'
        ));
    }
}
~~~~~~~~~~~~

Теперь ваши данные в намного лучшей форме, так как они инкапсулированы, валидированы и вообще находятся под 
вашим контролем. Вы можете:

- предотвращать появление вредоносных данных, фильтруя данные в set-методах:

{lang="php"}
~~~~~~~~~~~~
class ContactDetails
{
    public function setMessage($message)
    {
        $this->message = strip_tags($message);
    }
}
~~~~~~~~~~~~

- легко задавать значения по умолчанию (без необходимости знать структуру данных):

{lang="php"}
~~~~~~~~~~~~
public function contactAction(Request $request)
{
    $contactDetails = ContactDetails::createForUser($this->getUser());

    $form = $this->createForm(new ContactFormType(), $contactDetails);

    // ...
}
~~~~~~~~~~~~

- работать с объектом известного типа после привязки и валидации формы:

{lang="php"}
~~~~~~~~~~~~
public function contactAction(Request $request)
{
    $form = $this->createForm(new ContactFormType());

    if ($request->isMethod('POST')) {
        $form->bind($request);
        if ($form->isValid()) {
            $contactDetails = $form->getData();

            // переменная $contactDetails является экземпляром ContactDetails
        }
    }
}
~~~~~~~~~~~~

> Резюмируем: все формы в вашем приложении:
> 
> - Должны иметь опцию data_class, указывающую на определённый класс.
> - Должны быть определены в своих собственных классах, наследуемых от AbstractType.
> - Предпочтительно должны быть определены как сервисы, для повторного использования.

### Валидация значений из запроса

Объект запроса в основе своей является лишь обёрткой для суперглобальных массивов PHP. В файле /web/app.php
в можете увидеть, как именно создаётся объект запроса:

{lang="php"}
~~~~~~~~~~~~
$request = Request::createFromGlobals();
~~~~~~~~~~~~

Внутри этого метода вы можете найти такую строку:

{lang="php"}
~~~~~~~~~~~~
$request = new static($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);
~~~~~~~~~~~~

> @dbykadorov: в более старших версиях Symfony, она будет иметь немного другой вид:
>
> {lang="php"}
> ~~~~~~~~~~~~
> $request = self::createRequestFromFactory($_GET, $_POST, array(), $_COOKIE, $_FILES, $server);
> ~~~~~~~~~~~~

Таким образом, хотя вы можете чувствовать себя более защищёнными, получая данные из объекта
запроса `$request->query->get('page')`, по сути этот метод не более защищён, чем простой вызов 
`$_GET['page']`. Хотя в контексте Symfony следует всегда использовать объект запроса для получения его
данных, но вы всегда должны относиться с подозрением к ним, валидировать их и принудительно
переводить в нужный формат. Строгая типизация и проверка допустимых значений и диапазонов строго 
обязательна.

#### Атрибуты запроса

##### Параметры маршрута

Прежде всего, если шаблон URI содержит подстановки, например id в `/comment/{id}`, и некоторый запрос соответствует
этому шаблону, RouterListener должен убедиться, что все параметры скопированы в объект запроса в качестве атрибутов.
Эти атрибуты будут использованы классом ControllerResolver для сбора аргументов контроллера, основываясь на именах
параметров и подсказками типов. Вы можете ознакомиться с разделом книги 
[События, приводящие к ответу](#events_leading_to_a_response), если хотите узнать детали этого процесса.

Так как большинство аргументов контроллера просто копируются напрямую (более или менее) из URI из запроса, 
вы должны очень осторожны, используя их. Во-первых, вы должны позаботиться о требованиях к параметрам маршрута
(типа id). Требования определяются в виде регулярных выражений. По умолчанию требованием для параметра маршрута
является `[ˆ/]+`: они могут содержать любые символы, кроме слэша. Поэтому вы должны определить более жёсткие 
требования, например `\w+`, что будет означать как минимум "слово" (которое может содержать латинские буквы a-z, A-Z,
цифры 0-9 и подчерк _) или `\d+`, что будет означать как минимум одну цифру (0-9). Если вы ещё не знакомы с 
регулярными выражениями, вы срочно должны познакомиться с ними (как вы могли заметить ранее, они также используются
при работе с путями, определяемыми в security.yml). Ниже вы можете найти несколько примеров маршрутов с ограничениями:

{lang="php"}
~~~~~~~~~~~~
/**
 * id может быть только лишь числом:
 * @Route("/comment/{id}", requirements={"id"="\d+"})
 */

/**
 * alias может содержать как минимум одну букву в нижнем регистре, цифру или тире:
 * @Route("/user/{alias}", requirements={"alias"="[a-z0-9\-]+"})
 */

/**
 * type может иметь лишь значения 'commercial' или 'non-commercial':
 * @Route("/create-account/{type}", requirements={
 *     "type"="commercial|non-commercial"
 * })
 */
~~~~~~~~~~~~

Важно прроверять корректность этих значений на ранних стадиях, иначе некорректные значения могут быть использованы
в качестве аргументов при вызове методов сервисов, где они могут вызвать InvalidArgumentExceptions или, того хуже,
разного рода необъяснимые ошибки.

#### Query (GET) и request (POST) параметры

В жизни случается много различных ситуаций, когда вам потребуется некоторая гибкость в отношении
параметров запроса в контроллере: вы можете использовать параметры query в вашем URI (например, ?page=1, т.е GET
параметры), или же параметры запроса, отправленные в его теле (т.е. POST параметры). Однако, ни те ни
другие значения не заслуживают доверия. GET и POST данные легко могут быть подменены на такие значения,
которые вы не ожидаете получить. Следовательно, когда вы получаете эти данные из объекта запроса:

- Выполняйте валидацию при помощи компонентов Form и Validator, используя Form::bind() (@dbykadodov: в более поздних
версиях Symfony - Form:handleRequest())

- Или:
    - Приводите значения к типу, который вы ожидаете (чаще всего это будет строка или целое число) и
    - Выполняйте валидацию этих значений самостоятельно при помощи метода validateValue() из сервиса validator. 
    Вам может потребоваться проверить диапазон значений ("тут должно быть как минимум значение 1") или соответствие 
    одной из опций ("тут дожно быть либо значение 'commercial', либо 'non-commercial'"). 

Например:

{lang="php"}
~~~~~~~~~~~~
use Symfony\Component\Validator\Constraints\Choice;

public function createAccountAction()
{
    $userTypeConstraint = new Choice(array(
        'choices' => array('commercial', 'non-commercial')
    );

    $errorList = $this->get('validator')->validateValue(
        $request->query->get('userType'),
        $userTypeConstraint
    );

    if (count($errorList) == 0) {
        // тип пользователя верный
    }
}
~~~~~~~~~~~~

> #### Не используйте $request->get()!
>
> Не используйте $request->get(), потому что внутри он выглядит вот так (в версии Symfony 2.3):
> 
> {lang="php"}
> ~~~~~~~~~~~~
> public function get($key, $default = null, $deep = false)
> {
>     return $this->query->get($key,
>         $this->attributes->get($key,
>             $this->request->get($key, $default, $deep),
>         $deep),
>     $deep);
> }
> ~~~~~~~~~~~~
> 
> @dbykadorov: в Symfony 2.8+ этот метод выглядит по-опрятне.
>
> {lang="php"}
> ~~~~~~~~~~~~
> public function get($key, $default = null)
> {
>     if ($this !== $result = $this->attributes->get($key, $this)) {
>         return $result;
>     }
> 
>     if ($this !== $result = $this->query->get($key, $this)) {
>         return $result;
>     }
> 
>     if ($this !== $result = $this->request->get($key, $this)) {
>         return $result;
>     }
> 
>     return $default;
> }
> ~~~~~~~~~~~~
> 
> Тем не менее, я поддерживаю Маттиаса в его предостережении. Безусловно удобно получать параметры запроса,
> не задумываясь, GET они или POST. Но, с точки зрения безопасности, вы всегда должны контролировать контекст
> выполнения вашего запроса. Было бы странно ожидать данные, отправленные через POST, но получать их фактически
> через GET.

Всегда извлекайте данные специфическим для них способом, будь то query string, post data или прочие атрибуты 
запроса. Если ранее вы использовали суперглобальные переменные, то теперь просто обращайтесь к соответствующему 
хранилищу параметров (aka "parameter bag") класса запроса:

- `$_GET['key']` теперь будет `$request->query->get('key')`
- `$_POST['key']` теперь будет `$request->request->get('key')`

##### Используем ParamFetcher

Имеется также ещё один инструмент, который я бы хотел упомянуть. Он является частью бандла  
[FOSRestBundle](https://github.com/FriendsOfSymfony/FOSRestBundle), который предоставляет мощный инструментарий
для создания REST-подобных вебсервисов. Он также предоставляет очень удобный способ валидации параметров запроса
путём добавления дополнительных настроек в форму или же аннотаций для каждого параметра запроса, который вам 
будет нужен. Например, вот как вы можете сконфигурировать параметр "page", который должен содержать только цифры,
и по умолчанию равняется 1:

{lang="php"}
~~~~~~~~~~~~
use FOS\RestBundle\Request\ParamFetcher;
use FOS\RestBundle\Controller\Annotations\QueryParam;

/**
 * @QueryParam(
 *   name="page",
 *   requirements="\d+",
 *   default="1",
 *   description="Page number"
 * )
 */
public function listAction(ParamFetcher $paramFetcher)
{
    $page = $paramFetcher->get('page');
}
~~~~~~~~~~~~

Этот способ работает похожим образом и для POST данных, которые не используются в какой-либо форме:

{lang="php"}
~~~~~~~~~~~~
use FOS\RestBundle\Request\ParamFetcher;
use FOS\RestBundle\Controller\Annotations\RequestParam;

/**
 * @RequestParam(name="username", requirements="\w+")
 */
public function deleteAccountAction(ParamFetcher $paramFetcher)
{
    ...
}
~~~~~~~~~~~~

Даже если ваше приложение не имеет никакого REST API, вы всё-равно можете установить FOSRestBundle
без каких-либо негативных последствий. Просто убедидтесь, что вы отключили все его слушатели,
кроме ParamFetcherListener:

{lang="yml"}
~~~~~~~~~~~~
# in /app/config/config.yml
fos_rest:
    param_fetcher_listener: true
~~~~~~~~~~~~

### Очистка HTML

У вас в приложении, вероятно, есть формы, которые позволяют пользователям форматировать текст с использованием
редакторов rich text (или wysiwyg), делать его жирным, курсивом, подчёркивать, и может даже позволяете пользователям
втсалять их собственные ссылки в текст. Плохая носвость для вас состоит в том, что это конечно же очень небезопасная
функция. Вы должны очень сильно озаботиться об ограничениях на доступные пользователям HTML-таги и тем более атрибуты,
которое могут быть даже более опасны, так как могут содержать JavaScript. И не думайте, что `alert('Hi!');` это
худшая вещь, которую пользователь может провернуть через ваш редактор! Даже незакрытый таг может неделать бед - 
представьте, если в вашей HTML разметке случайно появится лишний закрывающий таг `</div>` (или же поигратесь с 
любым сайтом через Dev tools браузера). 

Во-первых, не полагайтесь на языки разметки типа Markdown для решения проблемы с инъекцией HTML.
Спецификация Markdown чётко и однозначно утверждает, что любая HTML разметка в исходном тексте должна
оставаться нетронутой и добавляться "как есть" в сгенерированный вывод. Во-вторых, не полагайтесь на второй
аргумент функции strip_tags, который позволяет оставлять лишь избранные таги, так как эта функция будет также
пропускать и все атрибуты внутри этих тагов. В-третьих: даже не мечтайте написать свои собственные регулярные 
выражения для того, чтобы разрешить использование некоторых тагов и атрибутов. Всегда будет оставаться
возможность хакнуть ваши самописные правила. Вместо этого используйте [HTMLPurifier](http://htmlpurifier.org/)
и настройте его под вашу конкретную ситуацию.

Имеется также замечательный бандл, которые интегрирует HTMLPurifier в Symfony приложение: 
[ExerciseHTMLPurifierBundle](https://github.com/Exercise/HTMLPurifierBundle) (@dbykadorov: бандл до сих
пор существует и поддерживает как Symfony 2.*, так и Symfony 3.*). Он определяет отдельный сервис для каждой
конфигурации, которую вы определите в config.yml. Он также поддерживает автоматическую фильтрацию значений форм.

#### Автоматизация очистки

Проблема такова: в каждом Symfony-приложении вы должны вручную заботится об очистке входных данных.
Было бы здорово, если бы все атрибуты запроса фильтровались бы автоматически на основании некоторых правил
или же когда формы или сущности должны были бы содержать только стопроцентно-чистые значения. К сожалению,
прямо сейчас в мире open source я не знаком ни с чем, что бы могло выполнить эту задачу =( Прототипом такого
функционала может быть бандл [DMSFilterBundle](https://github.com/rdohms/DMSFilterBundle) (@dbykadorov: тоже жив
и поддерживает как Symfony 2.*, так и Symfony 3.*), но его текущее состояние не позволяет обрабатывать все нужные 
ситуации. Он фильтрует только входные данные форм для корневого объекта. Он также не фильтрует данные, которые 
устанавливаются у сущности вручную.