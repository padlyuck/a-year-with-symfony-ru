## Состояния и контекст

Сервисы можно разделить на две группы:

1. Статические сервисы
2. Динамические сервисы

Большинство сервисов, определённых в сервисном контейнере принадлежат к первой категории. Статический сервис выполняет одну и ту же работу каждый раз будучи вызванным. Получая на входе одни и те же значения такой сервис должен выдать одинаковый результат раз за разом. Примером такого сервиса могут быть сервис отправки email пользователю или сохранение объекта при помощи менеджера сущностей.

Во вторую категорию попадают сервисы, которые могут изменяться: когда вы используете динамический сервис, вы не можете заранее знать, работает ли он так, как вы ожидаете, так как результат его работы может зависеть от текущего запроса, или, в случае Symfony-приложения: от факта, что ядро обрабатывает запрос.

### Контекст безопасности

> #### @dbykadorov: ВАЖНО! Отличия в версиях 2.6 и страше
>
> Вообще говоря данный раздел уже изрядно устарел. Начиная с версии Symfony 2.6 `security.context` [объявлен устаревшим](http://symfony.com/blog/new-in-symfony-2-6-security-component-improvements) и в 3.0 был удалён. Обязанности контекста безопасности разделили другие сервисы, прежде всего `security.token_storage` и `security.authorization_checker`
>
> ```php
> // Symfony 2.5
> $user = $this->get('security.context')->getToken()->getUser();
> // Symfony 2.6
> $user = $this->get('security.token_storage')->getToken()->getUser();
>
> // Symfony 2.5
> if (false === $this->get('security.context')->isGranted('ROLE_ADMIN')) { ... }
> // Symfony 2.6
> if (false === $this->get('security.authorization_checker')->isGranted('ROLE_ADMIN')) { ... }
> ```
>
> Используются они схожим образом, так что кардинальных отличий не будет, но имейте это в виду.

Одним из очевидных примеров динамического сервиса является контекст безопасности (security context). Вернёт ли он вам объект пользователя, когда вы выполните вызов методов `->getToken()->getUser()`, зависит от многих факторов, прежде всего от запроса и от того, смог ли файрвол определить - залогинен пользователь или нет. Кроме того, многие сервисы зависят от security context'а, например, вот этот:

```php
use Symfony\Component\Security\Core\SecurityContextInterface;

class UserMailer
{
    private $securityContext;
    private $mailer;

    public function __construct(
        SecurityContextInterface $securityContext,
        \SwiftMailer $mailer
    ) {
        $this->securityContext = $securityContext;
        $this->mailer = $mailer;
    }

    public function sendMailToCurrentUser($subject, $body)
    {
        $token = $this->securityContext->getToken();
        if (!($token instanceof TokenInterface)) {
            // we are not behind a firewall
            return;
        }

        $user = $token->getUser();
        if (!($user instanceof User)) {
            // no logged in user
            return;
        }

        $message = \Swift_Message::newInstance()
            ->setTo($user->getEmailAddress())
            ->setSubject($subject)
            ->setBody($messageBody);

        $this->get('mailer')->send($message);
    }
}
```

Определение этого сервиса выглядит вот так:

```xml
<service id="user_mailer" class="UserMailer">
    <argument type="service" id="security.context" />
    <argument type="service" id="mailer" />
</service>
```

Внутри контроллера вы можете использовать этот сервис для того, чтобы отправить письмо текущему пользователю (обратите внимание на аннотацию `@Secure` - она позволяет быть уверенным, что тут пользователь будет залогинен и у него будет как минимум роль `ROLE_USER`):

```php
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use JMS\SecurityExtraBundle\Annotation\Secure;

class SomeController extends Controller
{
    /**
     * @Secure("ROLE_USER")
     */
    public function sendMailAction()
    {
        $this->get('user_mailer')->sendMailToCurrentUser('Hi', 'there!');
    }
}
```

Хотите знать, почему этот код является плохим? Ну... вот вам как минимум 2 причины:

1. Сервис `user_mailer` может быть использован только для отправки писем текущему юзеру. В то же время, ничего специфичного относительно текущего пользователя (по сравнению с прочими) тут не выполняется. Метод `sendMailToCurrentUser($subject, $body)` может быть легко заменен на `sendMailTo(User $user, $subject, $body)`. Это делает ваш класс более общим и пригодным для повторного использования.
2. Сервис `user_mailer` может быть использован только лишь в запросах, которые обслуживаются внутри какого-либо файрволла (TODO: найти когда файрвол перестал быть необходим для вызова функций безопасности (ранее вне файрвола кидалось исключение)). Если запросить сервис `user_mailer` из консольной команды, он будет совершенно бесполезен, так как в этом случае файрвол не будет определён. Решение первой проблемы решит и эту без дополнительных усилий с вашей стороны.

Итак, давайте изменим класс `UserMailer`, чтобы решить указанные проблемы:

```php
class UserMailer
{
    private $mailer;

    public function __construct(\SwiftMailer $mailer)
    {
        $this->mailer = $mailer;
    }

    public function sendMailToUser(User $user, $subject, $body)
    {
        $message = \Swift_Message::newInstance()
            ->setTo($user->getEmailAddress())
            ->setSubject($subject)
            ->setBody($body);

        $this->mailer->send($message);
    }
}
```

В результате у нас класс тал намного меньше, а код - чище. Теперь сервис `user_mailer` ничего не знает о пользователе, которому должен отправить письмо (что также хорошо): поэтому вам каждый раз нужно будет передавать объект класса `User`, который может быть, а может и не быть текущим пользователем.

Контроллер является отличным местом для определения текущего пользователя, так как мы точно знаем, что контроллер выполняется лишь во время обработки запроса, и мы можем быть уверены, что он защищён файрволлом, если мы заранее явно сконфигурировали это. В этом случае нам будет доступен "текущий пользователь" (предполагается что файрволл корректно настроен) и мы можем переписать наш контроллер следующим образом:

```php
class SomeController extends Controller
{
    /**
     * @Secure("ROLE_USER")
     */
    public function sendMailAction()
    {
        $user = $this->getUser();

        $this->get('user_mailer')->sendMailTo($user, 'Hi', 'there!');
    }
}
```

> #### Текущий пользователь
>
> Когда бы вы ни захотели выполнить какие-либо действия с текущим пользователем в сервисе, всегда желательно передавать его откуда-то извне, как аргумент или даже используя метод-сеттер, чем получать пользователя, используя `SecurityContext` в самом сервисе.

### Запрос

Токен пользователя добавляется в контекст безопасности один раз для каждого запроса, но только для мастер-запроса. Но другие сервисы, которые вы создаёте, могут зависеть от текущего объекта запроса, который отличается от мастер-запроса или под-запроса. Этот объект запроса доступен в виде сервиса `request`, который является динамическим. В какой-то момент времени (фактически, перед тем как ядро начнёт обработку запроса) этот сервис запроса будет недоступен и не сможет быть использован любым другим объектом в качестве зависимости. В то же время, может быть ситуация, когда существует более одного сервиса запроса, а именно - когда ядро обрабатывает подзапрос.

В сервисном контейнере эта проблема решается при помощи т.н. сфер действия (scopes) Контейнер может входить в сферы действия и покидать их; в момент перехода между сферами действия либо восстанавливается предыдущий сервис, либо для новой сферы действия предоставляется новый. В случае с запросом, есть несколько состояний, в которых может быть контейнер:

1. Контейнер находится в сфере действия `container`, сервис запроса не определён.
2. Ядро обрабатывает главный запрос, оно переводит контейнер в сферу действия `request` и создаёт сервис запроса.
3. Ядро обрабатывает подзапрос, оно переводит контейнер в сферу действия `request`, но уже для другого запроса и устанавливает подзапрос в качестве сервиса запроса.
4. Ядро завершает обработку подзапроса и выводит контейнер из сферы действия `request` для подзапроса. Восстанавливается предыдущий сервис запроса.
5. Ядро завершает обработку главного запроса и выводит контейнер из сферы действия запроса. Сервис запроса опять будет неопределён.

Таким образом, когда бы вы ни выполнили вызов `$container->get('request')` вы "всегда" получите текущий объект `Request`. Когда вам нужно предоставить сервис запроса одному из ваших объектов, для этого имеется [несколько способов](http://symfony.com/doc/2.8/service_container/scopes.html), которые я, тем не менее, категорически не рекомендую использовать.

> #### @dbykadorov: ВАЖНО! Отличия в версиях 2.8 и старше
>
> В Symfony, начиная с версии 2.8 принцип сфер действия - `scopes` [помечен как устаревший](http://symfony.com/blog/new-in-symfony-2-8-deprecating-scopes-and-introducing-shared-services). В `current` ветке документации нет более такой статьи, поэтому ссылка ведёт на документацию версии 2.8.
>
> Также изменения коснулись и сервиса запроса, который выше предлагается получать, например так: `$container->get('request')`. Эти изменения - часть процесса рефакторинга работы с запросом, который начался с версии 2.4 введением сервиса `request_stack` (см. [тут](http://symfony.com/blog/new-in-symfony-2-4-the-request-stack)), который позволил разрешить неопределённость с запросами, которую ранее пытались разрешить при помощи scopes.
>
> Таким образом, начиная с версии 2.8 рекомендуется (а с версии 3.0 другого варианта и нет) получать текущий запрос через `request_stack`:
>
> ```php
> // Где-то в контроллере
> ...
> public function foo () {
>     $request = $this
>         ->get('request_stack')
>         ->getCurrentRequest();
>     // ... делаем с запросом что нам требуется
> }
> ```
>
> В принципе, Маттиас как раз далее и предлагает альтернативы для этой ситуации, актуальные на момент написания им книги, для Symfony 2.3 и настоятельно не рекомендует писать ваш код, зависимым от сервиса запроса.

Сама по себе необходимость иметь доступ к запросу для выполнения каких-либо действий не является чем-то экстремально плохим. Но вы не должны зависеть от сервиса запроса. Положим вам нужно сделать что-то типа счётчика посещений страницы:

```php
use Symfony\Component\HttpFoundation\Request;

class PageCounter
{
    private $counter;

    public function __construct(Request $request)
    {
        $this->request = $request;
    }

    public function incrementPageCounter()
    {
        $uri = $this->request->getPathInfo();

        // каким-либо образом инкрементим счётчик посещений для этого URI
        ...
    }
}
```

Определение этого сервиса будет таким:

```xml
<service id="page_counter" class="PageCounter" scope="request">
    <argument type="service" id="request" />
</service>
```

Так как вы зависите от сервиса запроса, весь ваш сервис должен иметь сферу действия `request`.

В контроллере вызов счётчика в этом случае будет выглядеть так:

```php
class InterestingController extends Controller
{
    public function indexAction()
    {
        $this->get('page_counter')->incrementPageCounter();
    }
}
```

Несомненно, сервис `page_counter` имеет возможность получить URI текущей страницы, так как у него есть весь объект `Request`. Но:

1. Статистика может быть получена лишь при выполнении текущего запроса. Когда ядро завершит обработку запроса, сервис запроса будет установлен в `null` и наш счётчик посещений будет бесполезен.

2. Класс `PageCounter` тесно связан с объектом класса `Request`. Счётчику же, на самом деле, требуется лишь URI. И этот URI не обязательно может быть получен из объекта `Request`. Будет лучше, если мы передадим его в качестве аргумента метода `incrementPageCounter()`:
```php
public function incrementPageCounter($uri)
{
    ...
}
```

Эти две проблемы могут казаться надуманными, но в один прекрасный день вам может потребоваться импортировать посещения, собранные каким-либо другим способом и придётся вызывать метод `incrementPageCounter()` "вручную". В этому случае вы только порадуетесь, что ваш счётчик не привязан классу `Request`.

#### Избегаем зависимостей от текущего запроса

Имеется две главных стратегии, как можно избежать зависмости от текущего запроса:

##### Используем слушатель (event listener)

Как вы вероятно можете помнить из первой главы - ядро всегда отправляет событие `kernel.request` для каждого запроса, который оно обрабатывает. В этот момент вы можете использовать слушатель для выполнения действий, которые вы бы хотели выполнять для каждого запроса, например, инкрементить счётчик посещений страницы, или может быть [остановить дальнейшее выполнение, вызвав исключение](http://php-and-symfony.matthiasnoback.nl/2012/12/prevent-controller-execution-with-annotations-and-return-a-custom-response/).

```php
class PageCounterListener
{
    private $counter;

    public function __construct(PageCounter $counter)
    {
        $this->counter = $counter;
    }

    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event->getRequest();

        $this->counter->incrementPageCounter($request->getPathInfo());
    }
}
```

##### Предоставлять объект запроса во время выполнения

Когда вам необходим весь объект запроса целиком, всегда лучше начать его использование там, где вы точно уверены, что этот объект существует (и вы можете его получить) и в этом месте передать запрос в нужный сервис:

```php
class SomeController extends Controller
{
    public function indexAction(Request $request)
    {
        $this->get('page_counter')->handle($request);
    }
}
```

> ##### Поиск совпадений для запросов (request matcher)
> 
> Во многих ситуациях, в которых вам будет нужен объект запроса для вашего сервиса, вы, вероятно, хотите его использовать для выполнения каких-либо сравнений. В этом случае вы можете абстрагироваться от логики сравнения при помощи обнаружителя совпадений запроса (request matcher):
> 
> ```php
> use Symfony\Component\HttpFoundation\RequestMatcherInterface;
> use Symfony\Component\HttpFoundation\Request;
> 
> class MyRequestMatcher implements RequestMatcherInterface
> {
>     public function matches(Request $request)
>     {
>         return $request->getClientIp() === '127.0.0.1';
>     }
> }
> ```
> 
> Или используя стандартный `RequestMatcher`:
> 
> ```php
> use Symfony\Component\HttpFoundation\RequestMatcher;
> 
> $matcher = new RequestMatcher();
> $matcher->matchIp('127.0.0.1');
> // $matcher->matchPath('^/secure');
> ...
> 
> if ($matcher->matches($request)) {
>     ...
> }
> ```

##### Использование только нужных значений

Перед тем, как передать в сервис весь объект запроса, всегда спрашивайте себя: а нужна ли мне вся эта информация целиком? Или же мне нужна только её конкретная часть? Если это так, отвязывайте зависимость от запроса и передавайте в качестве аргументов лишь нужные вам данные:

Изменим это:

```php
class AccessLogger
{
    public function logAccess(Request $request)
    {
        $ipAddress = $request->getClientIp();

        // log the IP address
        ...
    }
}
```

На это:

```php
class AccessLogger
{
    public function logAccess($ipAddress)
    {
        ...
    }
}
```

Это сделает ваш код пригодным для повторного использования в других проектах, даже таких, которые не используют компонент Symfony `HttpFoundation`. См. также раздел книги [уменьшаем связность с фреймворком](#TODO).