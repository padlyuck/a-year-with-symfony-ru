## Приёмы создания сервисов

Сервис - это объект, зарегистрированный в сервисном контейнере с некоторым идентификатором (id), который может быть создан в любой момент при помощи этого контейнера.

### Обязательные зависимости

Многие объекты для выполнения своих функций нуждаются в других объектах,  скалярных значениях (например, ключ API) и, может быть, даже в массивах значений (скаляров или объектов). Эти объекты, скаляры и массивы называются зависимостями. Сначала мы рассмотрим, как вы можете определить обязательные зависимости для ваших сервисов.

#### Обязательные параметры конструктора

Самый простой способ передать сервису его зависимости - указать их в качестве аргументов конструктора:

```php
class TokenProvider
{
    private $storage;

    public function __construct(TokenStorageInterface $storage)
    {
        $this->storage = $storage;
    }
}
```

Определение сервиса для класса `TokenProvider` должно выглядеть таким образом:

```xml
<service id="token_provider" class="TokenProvider">
    <argument type="service" id="token_storage" />
</service>

<service id="token_storage" class="...">
</service>
```

Первый аргумент сервиса `token_provider` - это ссылка на сервис `token_storage`. Класс хранилища токенов, таким образом, должен реализовывать интерфейс `TokenStorageInterface`, иначе он не будет корректным аргументом и вы получите фатальную ошибку.

##### Абстрактные определения для дополнительных аргументов

Предположим, у вас есть другой провайдер токенов, `ExpiringTokenProvider`, который наследуется от `TokenProvider`, но имеет дополнительно свой аргумент конструктора - `$lifetime`:

```php
class ExpiringTokenProvider extends TokenProvider
{
    private $lifetime;

    public function __construct(TokenStorageInterface $storage, $lifetime)
    {
        $this->lifetime = $lifetime;

        parent::__construct($storage);
    }
}
```

Создавая определение сервиса для второго провайдера, вы можете просто скопировать аргумент из определения сервиса `token_provider`:

```xml
<service id="expiring_token_provider" class="ExpiringTokenProvider">
    <argument type="service" id="token_storage" />
    <argument>3600</argument><!-- lifetime -->
</service>
```

Однако, лучшим выходом из данной ситуации будет создание определения родительского сервиса, которое вы сможете использовать для определения дочерних сервисов, предоставляя им необходимые базовые аргументы:

```xml
<service id="abstract_token_provider" abstract="true">
    <argument type="service" id="token_storage" />
</service>

<service id="token_provider" class="TokenProvider"
    parent="abstract_token_provider">
</service>

<service id="expiring_token_provider" class="ExpiringTokenProvider"
    parent="abstract_token_provider">
    <argument>3600</argument><!-- lifetime -->
</service>
```

Абстрактный сервис из примера выше имеет один аргумент и отмечен как абстрактный. Сервисы провайдеров используют `abstract_token_provider` в качестве родителя. Сервис `token_provider` не имеет дополнительных аргументов, таким образом, он лишь наследует первый аргумент конструктора  от `abstract_token_provider`. Сервис `expiring_token_provider` также наследует первый аргумент `token_storage`, а также добавляет свой дополнительный аргумент `$lifetime`.

> #### Наследование свойств
>
> Вне зависимости от того, является ли родительский сервис абстрактным или нет, дочерний сервис наследует ниже перечисленные свойства родительского сервиса:
>
> - Класс
> - Аргументы конструктора (в порядке их появления)
> - Вызовы методов после создания экземпляра класса (@dbykadorov: судя по всему, имеются в виду call вызовы при использовании [setter injection](http://symfony.com/doc/current/service_container.html#optional-dependencies-setter-injection))
> - Свойства, используемые для `property injection` (недостатки этого способа внедрения параметров описаны [тут](http://symfony.com/doc/current/service_container/injection_types.html#property-injection))
> - Фабричный класс или сервис, фабричный метод
> - Конфигуратор (штука весьма экзотичная, не рассматривается в данной книге)
> - Файл (необходимый для создания сервиса)
> - Признак, является ли создаваемый сервис публичным

#### Вызов обязательных set-методов (setters)

Иногда вы можете попасть в ситуацию, когда вы не захотите (или не сможете) переопределить конструктор сервиса и, следовательно, не сможете добавить дополнительные параметры в него, или же, возможно, некоторые зависимости ещё не определены в момент создания класса сервиса. В таких случаях вы можете добавить в ваш класс set-метод, что позволит внедрить зависимость сразу после создания сервиса (или, фактически, в любой момент после создания):

```php
class SomeController
{
    private $container;

    public function setContainer(ContainerInterface $container)
    {
        $this->container = $container;
    }

    public function indexAction()
    {
        $service = $this->container->get('...');
    }
}
```

Так как контроллеру из примера выше для выполнения метода `indexAction()` необходим экземпляр `ContainerInterface`, вызов `setContainer` является обязательным. Поэтому в определении сервиса для него вы должны позаботиться о внедрении сервисного контейнера:

```xml
<service id="some_controller" class="SomeController">
    <call method="setContainer">
        <argument type="service" id="service_container" />
    </call>
</service>
```

Преимущества при использовании set-методов для внедрения зависимостей в том, что вам не нужно указывать все зависимости в виде аргументов конструктора. Иногда это означает, что вам конструктор и вовсе не понадобится, или же вы можете оставить конструктор в неизменном виде. Недостатком данного метода является возможность ситуации, когда вы забудете вызвать set-метод, что приведёт к отсутствию необходимых зависимостей. В примере выше это приведёт к вызову метода `get()` от `null`, что, в свою очередь, вызовет фатальную ошибку PHP. По моему мнению, этот недостаток перекрывает все достоинства данного подхода, так как код получается "с душком", который называется `временнАя связность` (@dbykadorov: от слова "время", имеется в виду, что работоспособность вашего кода зависит от того был ли перед использованием сервиса вызван нужный set-метод или вы забыли добавить его в описание сервиса) или `temporal coupling`. Таким образом, этот тип внедрения делает ваш класс менее надёжным (@dbykadorov: о `temporal coupling` в PHP можно дополнительно почитать, например, [тут](https://habrahabr.ru/post/281330/)).

Для того, чтобы предотвратить серьёзные сбои (и чтобы помочь разработчику, который будет исправлять проблему, если она всё-таки возникнет) вы можете ограничить доступ к зависимому свойству через его геттер (метод `getXxx()`) и в нём проверять валидность соответствующего значения, например, вот так:

```php
class SomeController
{
    public function indexAction()
    {
        $service = $this->getContainer()->get('...');
    }

    private function getContainer()
    {
        if (!($this->container instanceof ContainerInterface)) {
            throw new \RuntimeException('Service container is missing');
        }

        return $this->container;
    }
}
```

> #### ContainerAware
>
> Компонент Symfony DependencyInjection содержит интерфейс `ContainerAwareInterface` и абстрактный класс `ContainerAware`, которые вы можете использовать для того, чтобы указать, что класс "осведомлён" ("aware" в оригинале) о сервисном контейнере. Использование этих классов предоставит вам set-метод по имени `setContainer()`, с помощью которого вы сможете передать сервисный контейнер в ваш класс. Контроллеры, которые реализуют интерфейс `ContainerAwareInterface`, автоматически получают доступ к контейнеру при помощи этого set-метода. Стандартный класс `Controller` из состава Symfony FrameworkBundle является "осведомлённым-о-контейнере" - `container-aware`. См. также [Определение контроллера для запуска](#resolving_the_controller).

##### Вызов методов в абстрактных сервисах

Когда вы создаёте `container-aware` сервис, у вас будет много дублирующего кода в его определении. Разумным будет добавить вызов метода `setContainer()` в определение абстрактного сервиса:

```xml
<service id="abstract_container_aware" abstract="true">
    <call method="setContainer">
        <argument type="service" id="service_container" />
    </call>
</service>

<service id="some_controller" class="SomeController"
    parent="abstract_container_aware">
</service>
```

> #### Соглашение об именовании родительских сервисов
>
> Определения родительских сервисов не обязательно должны быть абстрактными. Однако, когда вы опускаете атрибут `abstract="true"`, определение родительского сервиса будет трактоваться как определение обычного сервиса (и соответствующим образом валидироваться).
>
> Если же вы хотите создать определение абстрактного сервиса - пометьте его таковым, присвоив атрибуту `abstract` значение `true` и добавьте префикс `abstract_` к его id (по аналогии с абстрактными классами, имена которых традиционно начинаются с `Abstract`).
>
> Если же у вас есть определение родительского сервиса, который также должен быть самостоятельным сервисом, добавлять атрибут `abstract` не нужно, но, возможно, будет полезным добавить префикс `base_` к его id.

### Необязательные (опциональные) зависимости

Иногда зависимости являются не обязательными. Термин "не обязательные зависимости" может вам показаться противоречивым, так как если вы реально от чего-то не зависите, странно называть это "зависимостями". Однако, встречаются ситуации, когда один сервис знает как использовать другой сервис, но в общем-то этот другой сервис не является необходимым, для выполнения его функций. Например, сервис может знать, как использовать сервис журналирования (логгер) для того, чтобы писать в лог какие-либо отладочные данные.

#### Необязательные аргументы конструктора

В случае, когда класс вашего сервиса знает, как работать с логгером, он может иметь необязательный аргумент конструктора для него:

```php
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Psr\Log\LoggerInterface;

class AuthenticationListener
{
    private $eventDispatcher;
    private $logger;

    public function __construct(
        EventDispatcherInterface $eventDispatcher,
        LoggerInterface $logger = null
    ) {
        $this->eventDispatcher = $eventDispatcher;
        $this->logger = $logger;
    }
}
```

Для аргументов конструктора, которые должны быть либо экземплярами указанных классов, либо могут отсутствовать, вы можете использовать значение по умолчанию `null`. В этом случае в определении вашего сервиса вы можете выбрать стратегию поведения в случае их отсутствия:

```xml
<service id="authentication_listener" class="AuthenticationListener">
    <argument type="service" id="logger" on-invalid="ignore" />
</service>
```

Стратегия `ignore` на данный момент эквивалентна null-стратегии, в том смысле, что конструктор будет вызван со значением null, вместо запрошенного сервиса, если тот недоступен. Есть еще стратегия `exception`, которая применяется по умолчанию. При её использовании будет вызвано исключение, если внедряемый сервис не будет найден.

> #### Проверка необязательных зависимостей
>
> Если вы хотите проверить, внедрена или нет необязательная зависимость, вы должны написать примерно такой код:
>
> ```php
> if ($this->logger instanceof LoggerInterface) {
>     ...
> }
> ```
>
> Это более надёжный способ проверки, чем сравнение с NULL:
>
> ```php
> if ($this->logger !== null) {
>     ...
> }
> ```
>
> Думайте об этом в таком ключе: если что-то не является NULL, можем ли мы быть уверены, что это logger?

#### Необязательные вызовы set-методов

Также, как и в случае с обязательными зависимостями, иногда бывает удобно/необходимо внедрить необязательные зависимости при помощи set-методов. Как правило, эта потребность возникает, если вы не хотите захламлять сигнатуру конструктора:

```php
class AuthenticationListener
{
    private $eventDispatcher;
    private $logger;

    public function __construct(EventDispatcherInterface $eventDispatcher)
    {
        $this->eventDispatcher = $eventDispatcher;
    }

    public function setLogger(LoggerInterface $logger = null)
    {
        $this->logger = $logger;
    }
}
```

В определении сервиса вы можете добавить вызов метода `setLogger()` с сервисом журналирования в качестве аргумента. Вы также можете указать, что этот аргумент должен быть проигнорирован, в случае, если соответствующий сервис не будет найден (что делает эту зависимость по-настоящему необязательной):

```xml
<service id="authentication_listener" class="AuthenticationListener">
    <call method="setLogger">
        <argument type="service" id="logger" on-invalid="ignore" />
    </call>
</service>
```

Аргумент вызова метода `setLogger()` может иметь значение NULL (когда сервис не определён), но метод будет вызван в любом случае, таким образом вы должны иметь в виду, что NULL является одним из валидных аргументов вызова метода `setLogger()`.

> #### Определение закрытых (non-public) зависимостей
>
> Когда вы пишете код в true-ООП стиле, у вас всегда будет куча небольших сервисов, каждый из которых выполняет только одну фиксированную функцию. Сервисы более высокого уровня будут внедрять их в качестве зависимостей. Сервисы более низких уровней, как правило, не должны пересекаться между собой; они лишь выполняют роль помощников для сервисов более высокого уровня. Чтобы не допустить возможности использования низкоуровневых сервисов в других частях приложения, например, так:
>
> ```php
> $container->get('low_level_service_id');
> ```
>
> вы должны пометить их как закрытые (non-public), для этого в определении низкоуровневого сервиса нужно присвоить атрибуту public значение "false":
>
> ```xml
> <service id="low_level_service_id" class="..." public="false">
> </service>
> ```

### Коллекции сервисов

В большинстве случаев вы будете внедрять зависимости через конструктор или аргументы set-методов. Но иногда возникает необходимость внедрить в качестве зависимости целую коллекцию сервисов, например, если вы хотите предоставить несколько альтернатив (стратегий) для достижения определённых целей:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct(array $renderers)
    {
        $this->renderers = $renderers;
    }

    public function render($object)
    {
        foreach ($this->renderers as $renderer) {
            if ($renderer->supports($object) {
                return $renderer->render($object);
            }
        }
    }
}
```

Определение такого сервиса может выглядеть следующим образом:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument type="collection">
        <argument type="service" id="domain_object_renderer" />
        <argument type="service" id="user_renderer" />
    </argument>
</service>
```

Аргумент типа `collection` будет преобразован в массив, содержащий сервисы, id которых перечислены в этой коллекции:

```php
array(
    0 => ...
    1 => ...
)
```

Вы также можете для каждого элемента коллекции указать ключ при помощи атрибута `key`:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument type="collection">
        <argument
            key="domain_object" type="service"
            id="domain_object_renderer" />
        <argument
            key="user" type="service"
            id="user_renderer" />
    </argument>
</service>
```

Значение атрибута `key` будет использовано в качестве ключа для соответствующих значений коллекции:

```php
array(
    'domain_object' => ...
    'user' => ...
)
```

#### Вызов нескольких методов

Если вы включите "строгий" режим и перечитаете код класса `ObjectRenderer`, вы, вероятно, заметите, что нельзя доверять массиву `$renderers` в том, что он содержит только валидные рендереры (которые, к примеру, должны реализовывать интерфейс `RendererInterface`). Следовательно, вы, вероятно, захотите выделить отдельный метод для добавления рендерера:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct()
    {
        $this->renderers = array();
    }

    public function addRenderer($name, RendererInterface $renderer)
    {
        $this->renderers[$name] = $renderer;
    }
}
```

Конечно же, если имя рендерера не имеет значения, можно убрать параметр `$name`. Важно тут другое: когда кто-либо вызовет метод `addRenderer` и передаст ему в качестве аргумента объект, который не является реализацией интерфейса `RendererInterface`, этот вызов не будет успешным, так как не будет соблюдено ограничение по типу аргумента. Определение сервиса также необходимо изменить, чтобы для каждого рендерера вызывался бы метод `addRenderer()`:

```xml
<service id="object_renderer" class="ObjectRenderer">
    <call method="addRenderer">
        <argument>domain_object</argument>
        <argument type="service" id="domain_object_renderer" />
    </call>
    <call method="addRenderer">
        <argument>user</argument>
        <argument type="service" id="user_renderer" />
    </call>
</service>
```

#### Лучшее из двух миров

Возможно вас также заинтересует идея о том, как объединить подходы для работы с коллекциями сервисов, описанные выше, что позволило бы разработчикам передавать набор рендереров по-умолчанию через аргумент конструктора и/или добавлять рендереры один за другим, используя метод `addRenderer()`:

```php
class ObjectRenderer
{
    private $renderers;

    public function __construct(array $renderers)
    {
        foreach ($renderers as $name => $renderer) {
            $this->addRenderer($name, $renderer);
        }
    }

    public function addRenderer($name, RendererInterface $renderer)
    {
        $this->renderers[$name] = $renderer;
    }
}
```

#### Метки сервисов (tags)

Мы уже умеем добавлять рендереры вручную, но что, если другие части вашего приложения (например, другие бандлы) должны иметь возможность регистрировать свои рендереры? Наилучшим способом достичь этого будет использование меток (тагов) для сервисов:

```xml
<!-- in some other bundle -->
<service id="date_time_renderer" class="DateTimeRenderer">
    <tag name="specific_renderer" alias="date_time" />
</service>
```

У каждого тага есть имя, которое вы можете выбрать самостоятельно. Каждый таг также может иметь дополнительные атрибуты (например, `alias` в примере выше). Эти атрибуты в дальнейшем позволят вам определять дальнейшее повение сервиса.

Для того, чтобы получить список всех сервисов с нужным тагом, вам нужно создать т.н. `compiler pass`, например такой:

```php
namespace Matthias\RendererBundle\DependencyInjection\Compiler;

use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        // получаем все сервисы, отмеченные определённым тагом из всего проекта
        $taggedServiceIds
            = $container ->findTaggedServiceIds('specific_renderer');

        $objectRendererDefinition
            = $container->getDefinition('object_renderer');

        foreach ($taggedServiceIds as $serviceId => $tags) {

            // сервисы могут иметь более одного тага с одни и тем же именем
            foreach ($tags as $tagAttributes) {

                // вызываем метод addRenderer() для того, чтобы зарегистрировать рендерер
                $objectRendererDefinition
                    ->addMethodCall('addRenderer', array(
                        $tagAttributes['alias'],
                        new Reference($serviceId),
                    ));
            }
        }
    }
}
```

Созданный выше класс `compiler pass` нужно зарегистрировать в классе вашего бандла:

```php
use Matthias\RendererBundle\DependencyInjection\Compiler\RenderersPass;
use Symfony\Component\DependencyInjection\ContainerBuilder;

class RendererBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        $container->addCompilerPass(new RenderersPass());
    }
}
```

Метод `process()` класса `RenderersPass` в первую очередь получает все сервисы с тагами, которые имеют имя `specific_renderer`. В результате будет получен массив, ключами которого будут id сервисов, а значениями - массив их атрибутов. Так сделано потому, что определение любого сервиса может иметь более одного тага с одним и тем же именем (но, возможно, с другими атрибутами).

Потом запрашивается определение сервиса `object_renderer` для класса `ObjectRenderer`, после чего выполняется цикл по всем найденным тагам. В каждой итерации создаётся экземпляр класса `Reference`, который ссылается на текущий (в данной итерации) сервис рендерера (который, в свою очередь, помечен тагом `specific_renderer`) и вместе с значением атрибута `alias` они используются в качестве аргументов для вызова метода `addRenderer()`.

Вместе это означает, что когда сервис `object_renderer` будет запрошен, сначала будет создан экземпляр класса `ObjectRenderer`. Затем будет выполнено несколько вызовов метода `addRenderer()`, которые добавят рендереры, отмеченные тагом `specific_renderer`.

#### Вызов одного метода

Есть много возможностей обработки сервисов в `compiler pass`. Например, вы можете собрать ссылки (references) на сервисы в массив и обработать их все разом, указав их в качестве аргумента метода `setRenderers()`:

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        $renderers = array();

        foreach ($taggedServiceIds as $serviceId => $tags) {
            foreach ($tags as $tagAttributes) {
                $name = $tagAttributes['alias'];
                $renderer = new Reference($serviceId);
                $renderers[$name] = $renderer;
            }
        }

        $objectRendererDefinition
            ->addMethodCall('setRenderers', array($renderers));
    }
}
```

#### Замена аргумента конструктора

Если имеется возможность внедрения коллекции сервисов в виде конструктора - например, рендереры из примера выше - есть также другой способ сделать это, установив аргумент конструктора напрямую:

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        $renderers = array();

        // получаем референсы на сервисы
        ...

        $objectRendererDefinition->replaceArgument(0, $renderers);
    }
}
```

Замена аргумента может быть выполнена только в случае, если этот аргумент определён первым (например, как пустой аргумент):

@dbykadorov: TODO - перепроверить, либо неправильно понял, либо это не всегда так

```xml
<service id="object_renderer" class="ObjectRenderer">
    <argument /><!-- наши рендереры -->
</service>
```

#### Передаём ID сервисов вместо референсов

Когда вы запрашиваете сервис `object_renderer`, все рендереры, переданные ему в качестве аргументов, также будут созданы. В зависимости от цены (@dbykadorov: в плане производительности) создания этих рендереров, возможно, было бы неплохо предусмотреть возможность их "ленивой" загрузки - `lazy-loading`. Этого можно добиться, сделав `ObjectRenderer` "осведомлённым о контейнере" - `container-aware` и внедряя id сервисов вместо них самих:

```php
class LazyLoadingObjectRenderer
{
    private $container;
    private $renderers;

    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    public function addRenderer($name, $renderer)
    {
        $this->renderers[$name] = $renderer;
    }

    public function render($object)
    {
        foreach ($this->renderers as $name => $renderer) {
            if (is_string($renderer)) {
                // здесь $renderer - это id сервиса, строка
                $renderer = $this->container->get($renderer);
            }

            // проверяем, является ли renderer экземпляром RendererInterface
            ...
        }
    }
}
```

Также `compiler pass` нужно модифицировать таким образом, чтобы он не передавал ссылки на services, а только лишь их id:

```php
class RenderersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $taggedServiceIds = ...;

        $objectRendererDefinition = ...;

        foreach ($taggedServiceIds as $serviceId => $tags) {
            foreach ($tags as $tagAttributes) {
                $objectRendererDefinition
                    ->addMethodCall('addRenderer', array(
                        $tagAttributes['alias'],
                        $serviceId,
                    )
                );
            }
        }
    }
}
```

Также не забудьте указать сервисный контейнер в качестве аргумента конструктора:

```xml
<service id="object_renderer" class="LazyLoadingObjectRenderer">
    <argument type="service" id="service_container" />
</service>
```

И конечно же, любая из стратегий, описанных выше, может быть использована с этим классом, реализующим "ленивую" загрузку: вызов одного метода, вызов нескольких методов, замена аргумента.

Перед тем, как вы решите изменить свой класс для использования сервисного контейнера напрямую, пожалуйста, ознакомьтесь с разделами [Уменьшаем связность кода с фреймворком](#TODO), особенно [с заметкой о быстродействии](#TODO).

### Делегирование создания

Вместо того, чтобы создавать сервисы заранее при помощи их определений с указанием класса, аргументов конструктора и вызовов методов, вы можете не указывать все эти детали, делегировав их заполнение фабричному методу (`factory method`) во время выполнения. Фабричные методы могут быть как статичными методами, так и методами объектов. В первом случае вы можете указать имя класса и имя метода в качестве атрибутов при определении сервиса:

```xml
<service id="some_service" class="ClassOfResultingObject"
    factory-class="Some\Factory" factory-method="create">
    <argument>...</argument>
</service>
```

Когда сервис `some_service` будет запрошен в первый раз, он будет получен как результат вызова статического метода `Some\Factory::create()` с использованием указанных аргументов. Результат будет сохранён в памяти, поэтому фабричный метод будет вызван лишь раз (@dbykadorov: один раз в рамках текущего запроса, кэшироваться на диск такой вызов не будет). В наши дни большинство фабричных методов не являются статическими, что означает вызов фабричного метода у экземпляра фабричного класса. Следовательно, этот экземпляр фабрики должен быть предварительно сам определён как сервис:

```xml
<!-- сервис, создаваемый фабрикой some_factory_service -->
<service id="some_service" class="ClassOfResultingObject"
    factory-service="some_factory_service" factory-method="create">
    <argument>...</argument>
</service>

<!-- собственно сервис самой фабрики -->
<service id="some_factory_service" class="Some\Factory">
</service>
```

#### Не очень полезно...

Хотя возможность делегирования создания сервисов другим сервисам выглядит великолепно, я не использовал её слишком часто. Эта возможность полезна по большей части только для случаев, когда сервис создаётся для PHP-классов из (не очень далёкого) прошлого, логика создания экземпляров которых часто спрятана внутри статических фабричных классов (помните `Doctrine_Core::getTable()`?).

Мои возражения против фабричных классов со статическими фабричными методами основаны на том, что статический код - это глобальный код и выполнение этого кода может иметь побочные эффекты, которые нельзя изолировать (например, в тестовом сценарии). Кроме того, любая зависимость такого статического фабричного метода по определению также должна быть статической, что очень плохо для изоляции и не даст вам возможности подменить часть логики создания своим кодом.

Фабрики-объекты (или фабричные сервисы) лишь немногим лучше. Тем не менее, необходимость их использования скорее всего указывает на проблемы в дизайне (архитектуре) приложения. Сервис не должен нуждаться в фабрике, так как он создаётся один раз заранее определённым (и детерминированным (@dbykadorov - т.е. при одинаковых входных данных получается одинаковый же результат)) способом и с момента создания он полностью готов к повторному использованию любым другим объектом. Переменными по отношению к сервису должны быть лишь аргументы методов, которые являются частью его публичного интерфейса (см. также [Состояние и Контекст](#TODO)).

#### Иногда всё-таки полезно...

Одним из частных случаев, когда использование фабричных сервиса и метода для получения сервиса оправдано, является случай с репозиториями Doctrine. Когда вам нужен один из них, вы, как правило, можете внедрить `entity manager` в качестве аргумента конструктора и позднее получить нужный репозиторий:

```php
use Doctrine\ORM\EntityManager;

class SomeClass
{
    public function __construct(EntityManager $entityManager)
    {
        $this->entityManager = $entityManager;
    }

    public function doSomething()
    {
        $repository = $this->entityManager->getRepository('User');

        ...
    }
}
```

Но, используя фабричный сервис, вы можете внедрить нужный репозиторий напрямую:

```php
class SomeClass
{
    public function __construct(UserRepository $userRepository)
    {
        $this->userRepository = $userRepository;
    }
}
```

Вот соответствующие определения сервисов для этого случая:

```xml
<service id="some_service" class="SomeClass">
    <argument type="user_repository" />
</service>

<service id="user_repository" class="UserRepository"
    factory-service="entity_manager" factory-method="getRepository">
    <argument>User</argument>
</service>
```

Если взглянуть на аргументы конструктора `SomeClass`, сразу становится ясно, что на входе ожидается репозиторий `User`, что намного более читабельно, нежели предыдущий пример, где `SomeClass` ожидает `EntityManager`.  Кроме того, класс сам по себе стал чище, а также стало проще создать замену для репозитория, например, когда вы будете писать модульный тест для этого класса. Вместо того, чтобы создать mock-объекты для менеджера сущности и репозитория, теперь можно создать только один - для репозитория.

### Создание сервисов вручную

Обычно вы создаёте сервисы, загружая их определения из файла:

```php
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

class SomeBundleExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $locator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new XmlFileLoader($container, $locator);
        $loader->load('services.xml');
    }
}
```

Но некоторые сервисы не могут быть определены в конфигурационном файле. Они должны создаваться динамически, потому что их имена, классы, аргументы, таги и прочие атрибуты не фиксированы.

#### Определение

Создание сервиса вручную означает создание экземпляра класса "определения" `Definition`, и (опционально) передачу ему имени класса. Определение получит идентификатор при его добавлении в `ContainerBuilder`:

```php
use Symfony\Component\DependencyInjection\Definition;

$class = ...; // присваиваем значение имени класса для определения

$definition = new Definition($class);

$container->setDefinition('the_service_id', $definition);
```

Эквивалентом этого определения был бы такой XML:

```xml
<service id="the_service_id" class="...">
</service>
```

Вы можете сделать определение закрытым (non-public), если оно существует лишь как зависимость для других сервисов:

```php
$definition->setPublic(false);
```

#### Аргументы

Когда для создания сервиса нужно передать в конструктор аргументы, вы можете задать их все разом:

```php
use Symfony\Component\DependencyInjection\Reference;

$definition->setArguments(array(
    new Reference('logger') // ссылка на другой сервис
    true // логическое (булево) значение,
    array(
        'table_name' => 'users'
    ) // массив
    ...
));
```

Аргументы должны быть ссылками на другие сервисы, массивами или скалярами (или их сочетаниями). Это требование - следствие того, что все определения сервисов в конечном итоге будут сохранены в простом PHP файле. Ссылка на другой сервис будет создана с использованием объекта `Reference` с указанием ID сервиса, который должен быть внедрён.

Вы также можете добавлять аргументы по одному, в том порядке, в котором они перечислены в конструкторе:

```php
$definition->addArgument(new Reference('logger'));
$definition->addArgument(true);
...
```

И, наконец, если вы модифицируете определение уже существующего сервиса с некоторым списком аргументов, вы можете заменить их, используя численные индексы:

```php
$definition->setArguments(array(null, null));

...

$definition->replaceArgument(0, new Reference('logger'));
$definition->replaceArgument(1, true);
```

Соответствующий XML выглядел бы так:

```xml
<service id="..." class="...">
    <argument type="service" id="logger" />
    <argument>true</argument>
</service>
```

#### Таги

Есть еще кое-что, что вы можете сделать, работая с объектом Definition: добавить таги (метки). Таг состоит из его имени и массива атрибутов. Определение может иметь более одного тага с одним именем:

```php
$definition->addTag('kernel.event_listener', array(
    'event' => 'kernel.request'
);
$definition->addTag('kernel.event_listener', array(
    'event' => 'kernel.response'
);
```

XML определение в этом случае было бы таким:

```xml
<service id="..." class="...">
    <tag name="kernel.event_listener" event="kernel.request">
    <tag name="kernel.event_listener" event="kernel.response">
</service>
```

#### Алиасы (псевдонимы)

Перед тем, как поговорить о том, что вам делать с вашими новыми знаниями, есть еще один момент, который вам надо знать - как создавать алиасы для сервисов:

```php
$container->setAlias('some_alias', 'some_service_id');
```

Теперь, когда бы вы ни запросили сервис `some_alias`, фактически вы получите сервис `some_- service_id`.

### Класс Configuration

Прежде чем продолжить, нужно дать несколько пояснений касательно класса `Configuration`. Вы могли обратить на него внимание ранее, а также, возможно, даже создавали его самостоятельно.

Большую часть времени вы будете использовать класс `Configuration` для того, чтобы определять все возможные конфигурационные опции для вашего бандла (обратите внимание, компонент Config имеет слабые связи и вы можете использовать всё сказанное ниже в совершенно другом контексте). Имя класса и его пространство имён не имеют особого значения, пока класс реализует интерфейс `ConfigurationInterface`:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('name_of_bundle');

        $rootNode
            ->children()
            // определяем узлы конфигурации
            ...
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Тут у нас один публичный метод - `getConfigTreeBuilder()`. Этот метод должен возвращать экземпляр `TreeBuilder`, который вы должны использовать для того, чтобы описать все возможные настройки вашего приложения, а также правила для их проверки на корректность (правила валидации). Создание конфигурационного дерева начинается с определения корневого узла:

```php
$rootNode = $treeBuilder->root('name_of_bundle');
```

Имя корневого узла должно быть именем бандла без суффикса "bundle", в нижнем регистре и с разделителем в виде подчерка. Например, имя корневого узла для `MatthiasAccountBundle` будет `matthias_account`. Корневой узел - это всегда узел типа "массив". Он может содержать любой дочерний узел, какой вы захотите:

```php
$rootNode
    ->children()
        ->booleanNode('auto_connect')
            ->defaultTrue()
        ->end()
        ->scalarNode('default_connection')
            ->defaultValue('default')
        ->end()
    ->end()
;
```

> #### Учимся составлять замечательные деревья конфигураций
>
> Если вы хотите стать профессионалом в создании бандлов, усердно практикуйтесь в создании конфигурационных деревьев. Конфигурация вашего бандла в этом случае будет значительно лучше и гибче. Подробнее об узлах конфигурации вы можете узнать в [документации компонента Config](http://symfony.com/doc/current/components/config/definition.html). Также обратите внимание на классы конфигурации сторонних бандров (@dbykadorov: например - Friends Of Symfony, FOS) и попробуйте последовать их примеру.

Как правило, вы будете использовать экземпляр класса Configuration в классе расширения вашего бандла, для того, чтобы обработать заданный набор конфигурационных массивов. Эти конфигурационные массивы собираются ядром, загружая все подходящие конфигурационные файлы (например, `config_dev`.yml, config.yml, parameters.yml, и т.д.).

```php
class MatthiasAccountExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );
    }
}
```

Метод `processConfiguration()` класса расширения создаёт экземпляр класса `Processor` и финализирует конфигурационное дерево, загруженное из объекта Configuration. Затем он просит processor обработать - выполнить валидацию и объединение - "сырых" конфигурационных массивов:

```php
final protected function processConfiguration(
    ConfigurationInterface $configuration,
    array $configs
) {
    $processor = new Processor();

    return $processor->processConfiguration($configuration, $configs);
}
```

Если ошибок валидации не выявлено, вы можете использовать конфигурационные значения любым необходимым вам способом. Вы можете определить или модифицировать параметры контейнера или изменить определения сервисов, основывающихся на конфигурационных значениях. В следующих главах мы обсудим много различных способов сделать это.

### Динамическое добавление тагов

Допустим, вы хотите создать универсальный слушатель (event listener), который слушает настраиваемый список событий, например, `kernel.request`, `kernel.response`, и т.д. Вот как мог бы выглядеть соответствующий класс Configuration:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('generic_listener');

        $rootNode
            ->children()
                ->arrayNode('events')
                    ->prototype('scalar')
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Он позволяет сконфигурировать список имён событий следующим образом:

```yaml
generic_listener:
    events: [kernel.request, kernel.response, ...]
```

Стандартный способ зарегистрировать "слушатель" заключается в добавлении тагов к сервису слушателя в файле services.xml:

```xml
<service id="generic_event_listener" class="...">
    <tag name="kernel.event_listener" event="..." method="onEvent" />
    <tag name="kernel.event_listener" event="..." method="onEvent" />
</service>
```

Но в нашем случае мы не знаем, какие события слушатель должен слушать, так что мы не можем указать их явно в файле конфигурации. К счастью, как мы уже знаем, мы можем добавлять таги к определению сервиса прямо на лету. Это можно провернуть в классе расширения контейнера:

```php
class GenericListenerExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );
    
        // загружаем services.xml
        $loader = ...;
        $loader->load('services.xml');
    
        $eventListener = $container
            ->getDefinition('generic_event_listener');
    
        foreach ($processedConfig['events'] as $eventName) {
            // добавляем таги kernel.event_listener для каждого из указанных событий
            $eventListener
                ->addTag('kernel.event_listener', array(
                    'event' => $eventName,
                    'method' => 'onEvent'
                ));
        }
    }
}
```

Есть ещё один шаг, который нужно выполнить, чтобы предотвратить "подвисание" сервиса слушателя, если ни одного события для него не сконфигурировано:

```php
if (empty($processedConfig['events'])) {
    $container->removeDefinition('generic_event_listener');
}
```

{#strategy_pattern_loading_exclusive_services}
### Используем паттерн Стратегия для загрузки сервисов

Часто бандлы предлагают разные способы выполнить ту или иную функцию. Например, бандл, предоставляющий функцию почтового ящика в каком-то виде, может иметь разные реализации хранилища, например, один менеджер хранения для Doctrine ORM, а другой для MongoDB. Чтобы предоставить возможность выбора конкретного менеджера хранения, давайте создадим класс конфигурации:

```php
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('browser');

        $rootNode
            ->children()
                ->scalarNode('storage_manager')
                    ->validate()
                        ->ifNotInArray(array('doctrine_orm', 'mongo_db')
                        ->thenInvalid('Invalid storage manager')
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Затем нужно создать файлы с определениями сервисов для каждого из менеджеров хранения, один - doctrine_orm.xml:

```xml
<services>
    <service id="mailbox.doctrine_orm.storage_manager" class="...">
    </service>
</services>
```

И другой - mongo_db.xml:

```xml
<services>
    <service id="mailbox.mongo_db.storage_manager" class="...">
    </service>
</services>
```

Затем вы должны загрузить один из этих файлов при помощи вот такого кода в классе расширения:

```php
class MailboxExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        // создаём XmlLoader
        $loader = ...;

        // загружаем только сервисы для выбранного менджера хранения
        $storageManager = $processedConfig['storage_manager'];
        $loader->load($storageManager.'.xml');

        // делаем выбранный менеджер дооступным по умолчанию
        $container->setAlias(
            'mailbox.storage_manager',
            'mailbox.'.$storageManager.'.storage_manager'
        );
    }
}
```

В конце мы создаём удобный алиас, для того, чтобы другие части приложения могли обращаться к сервису `mailbox.storage_manager`, не заботясь о том, какая именно схема хранения на самом деле используется. Тем не менее, этот способ не очень гибок: id каждого менеджера хранения должен соответствовать шаблону `mailbox.{storageManagerName}.storage_manager`. Будет лучше определить алиас внутри файла с определением сервисов:

```xml
<services>
    <service id="mailbox.doctrine_orm.storage_manager" class="...">
    </service>

    <service id="mailbox.storage_manager"
        alias="mailbox.doctrine_orm.storage_manager">
    </service>
</services>
```

Используя паттерн "стратегия" для загрузки сервисов, мы получаем следующие преимущества:

- Загружаются только те сервисы, которые реально будут использованы в данном конкретном приложении. Если у вас нет сервера MongoDB, то у вас не будет и сервисов, которые от него зависят.
- Такая конфигурация открыта для расширения, так как вы можете добавить имя другого менеджера хранения в список в классе Configuration и затем добавить определения сервисов и алиасов - всё готово.

### Загрузка и конфигурирование дополнительных сервисов

Предположим, у вас есть бандл, который должен заниматься фильтрацией входных данных. Вероятно, вы предоставляете несколько различных сервисов, например, сервисы для фильтрации данных html-форм, а также сервисы для фильтрации данных, сохранённых при помощи Doctrine ORM. Соответственно, должна быть возможность в любое время активировать или деактивировать любой из этих сервисов или целую коллекцию сервисов, так как они могут быть не применимы к вашей конкретной ситуации. Есть удобный способ добиться этого:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('input_filter');

        $rootNode
            ->children()
                ->arrayNode('form_integration')
                    // будет активно по умолчанию
                    ->canBeDisabled()
                ->end()
                ->arrayNode('doctrine_orm_integration')
                    // будет отключено по умолчанию
                    ->canBeEnabled()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Имея такое дерево конфигурации, вы можете активировать или деактивировать отдельные части бандла в config.yml:

```yaml
input_filter:
    form_integration:
        enabled: false
    doctrine_orm_integration:
        enabled: true
```

В классе расширения вам остаётся только загрузить соответствующие сервисы:

```php
class InputFilterExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        if ($processedConfig['doctrine_orm_integration']['enabled']) {
            $this->loadDoctrineORMIntegration(
                $container,
                $processedConfig['doctrine_orm_integration']
            );
        }

        if ($processedConfig['form_integration']['enabled']) {
            $this->loadFormIntegration(
                $container,
                $processedConfig['form_integration']
            );
        }

        ...
    }

    private function loadDoctrineORMIntegration(
        ContainerBuilder $container,
        array $configuration
    ) {
        // загружаем сервисы и т.д.
        ...
    }

    private function loadFormIntegration(
        ContainerBuilder $container,
        array $configuration
    ) {
        ...
    }
}
```

Каждая из отдельных частей бандла теперь может быть загружена независимо от других.

#### Подчищаем класс конфигурации

Одна или две части бандла можно легко поддерживать таким образом, как это описано выше, но если развивать ваш бандл таким образом, вскоре класс Configuration будет содержать слишком много строк кода для одного метода. Можно слегка подчистить этот код, задействовав метод `append()` в комбинации с несколькими приватными методами:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();

        $rootNode = $treeBuilder->root('input_filter');

        $rootNode
            ->append($this->createFormIntegrationNode())
            ->append($this->createDoctrineORMIntegrationNode())
        ;

        return $treeBuilder;
    }

    private function createDoctrineORMIntegrationNode()
    {
        $builder = new TreeBuilder();

        $node = $builder->root('doctrine_orm_integration');

        $node
            ->canBeEnabled()
            ->children()
                // тут можно добавить дополнительные опции конфигурации
                ...
            ->end();

        return $node;
    }

    private function createFormIntegrationNode()
    {
        ...
    }
}
```

### Конфигурируем сервис, который будем использовать

Вместо того, чтобы использовать паттерн "стратегия" для загрузки сервисов, вы также можете разрешить разработчикам конфигурировать вручную сервисы, которые они хотят использовать. Например, если вашему бандлу нужен какой-либо сервис-шифратор (encrypter) и бандл не содержит таковой, вы можете попросить разработчика указать ID сервиса-шифратора:

```yaml
matthias_security:
    encrypter_service: my_encrypter_service_id
```

Класс конфигурации в этом случае будет выглядеть таким образом:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('matthias_security');

        $rootNode
            ->children()
                ->scalarNode('encrypter_service')
                    ->isRequired()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

В классе расширения бандла вам нужно создать алиас для сконфигурированного сервиса.

```php
class MatthiasSecurityExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        $container->setAlias(
            'matthias_security.encrypter',
            $processedConfig['encrypter_service']
        );
    }
}
```

Таким образом, даже учитывая, что id сервиса-шифратора может быть любым, теперь вы всегда будете точно знать, как обратиться к нему из любого сервиса по известному вам и вашему бандлу псевдониму:

```xml
<service id="matthias_security.encrypted_data_manager" class="...">
    <argument type="service" id="matthias_security.encrypter" />
</service>
```

Конечно же, вы не можете быть уверены в том, что сконфигурированный вручную сервис - это действительно валидный экземпляр шифратора. Вы не можете удостовериться в этом на этапе конфигурации, поэтому придётся проверять во время выполнения. Типичный способ выполнить такую проверку - добавить подсказку типа (type-hint) в классы сервисов, которые используют этот сервис-шифратор:

```php
class EncryptedDataManager
{
    public function __construct(EncrypterInterface $encrypter)
    {
        // здесь мы можем быть уверены, что $encrypter валидный
    }
}
```

### Полностью динамическое определение сервисов

Также встречаются ситуации, когда заранее вы практически ничего не знаете о сервисе, который вам нужен, до того момента, когда у вас есть обработанная конфигурация. Предположим, вы хотите, чтобы пользователи вашего бандла могли определять сервисы в виде набора ресурсов. Эти ресурсы могут иметь тип `файл` или `директория`. Вы хотите создавать эти сервисы на лету, так как они могут отличаться от приложения к приложению и вам необходимо собирать их, используя особый таг - `resource`. Ваш класс Configuration для данного случая может выглядеть примерно так:

```php
class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('resource_management');

        $rootNode
            ->children()
                ->arrayNode('resources')
                    ->prototype('array')
                        ->children()
                            ->scalarNode('type')
                                ->validate()
                                    ->ifNotInArray(
                                        array('directory', 'file')
                                    )
                                    ->thenInvalid('Invalid type')
                                ->end()
                            ->end()
                            ->scalarNode('path')
                            ->end()
                        ->end()
                    ->end()
                ->end()
            ->end()
        ;

        return $treeBuilder;
    }
}
```

Пример конфигурации ресурсов:

```yaml
resource_management:
    resources:
        global_templates:
            type: directory
            path: Resources/views
        app_kernel:
            type: file
            path: AppKernel.php
```

Когда ресурсы определены таким образом, вы можете создавать определения сервисов для них в расширении контейнера:

```php
class ResourceManagementExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $processedConfig = $this->processConfiguration(
            new Configuration(),
            $configs
        );

        $resources = $processedConfig['resources'];

        foreach ($resources as $name => $resource) {
            $this->addResourceDefinition($container, $name, $resource);
        }
    }

    private function addResourceDefinition(
        ContainerBuilder $container,
        $name,
        array $resource
    ) {
        // определяем класс
        $class = $this->getResourceClass($resource['type']);

        $definition = new Definition($class);

        // добавляем таг
        $definition->addTag('resource');

        $serviceId = 'resource.'.$name;

        $container->setDefinition($serviceId, $definition);
    }

    private function getResourceClass($type)
    {
        if ($type === 'directory') {
            return 'Resource\Directory';
        } elseif ($type === 'file') {
            return 'Resource\File';
        }

        throw new \InvalidArgumentException('Type not supported');
    }
}
```

Если эти, созданные вручную, определения сервисов требуют некоторых аргументов, вызовов методов и т.д. - используйте техники, описанные выше, для того, чтобы добавить динамически и их.