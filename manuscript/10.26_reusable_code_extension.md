## Повторно используемый код должен быть открыт для расширения

Переиспользуемый код должен быть гибок. Пользователь вашего бандла должен иметь возможность настроить сервисы по-другому, нежели они были настроены в оригинальном проекте, под который вы их разработали. Он также должен иметь возможность заменить любой сервис бандла своей реализацией и при этом не обрушить все приложение. Другими словами, переиспользуемый код должен придерживаться принципа "открыт для расширения, закрыт для модификации". Нельзя ставить пользователя в ситуацию, когда он будет вынужден лезть в оригинальный код и патчить его, вместо этого он должен лишь заменять или расширять отдельные его части под свои нужды.

### Настраиваемое поведение

Для того, чтобы ваш бандл был гибким, он должен иметь обширный набор настраиваемых опций со значениями по умолчанию и информацией о том за что каждая из опций отвечает. Загружаться должны лишь те сервисы, которые определены посредством этих опций, предоставленных разработчиком (например в config.yml). Подробнее об этом читайте в разделе [Приёмы внедрения зависимостей](#patterns-of-dependency-injection). Там вы найдете много советов о том как сделать ваш бандл настраиваемым.

### Все должно быть заменяемым

Используя "проход компилятора" (compiler pass, по этому вопросу также смотрите раздел [Приёмы внедрения зависимостей](#patterns-of-dependency-injection)) можно заменять любое ранее созданное определение сервиса определением вашего сервиса или изменить класс или аргумент в существующем определении сервиса. Это означает, что если разработчик захочет заменить часть функциональности вашего бандла своей функциональностью, теоретически всегда есть способ сделать это. Есть несколько вещей, которые вам нужно сделать для того, чтобы помочь разработчикам заменять все что они могли бы захотеть заменить, оставляя при этом другие части бандла неизменными.

> #### Много маленьких классов, много отдельных обязанностей
> 
> Возможно вы захотите воспользоваться моим опытом: положим вы попытались воспользоваться неким open source бандлом, но вам не нравится часть функций, которые он предоставляет. Вы пытаетесь заменить часть этих функций, но количество изменений становится все больше и больше, пока вы фактически не разработаете свой собственный бандл. Проблема заключается в том, что в этом случае в бандле будет слишком слабое разделение ответственности (см. [о принципе разделения ответственности - “separation of concerns” в википедии](https://ru.wikipedia.org/wiki/Разделение_ответственности)): некоторые громоздкие классы будут стараться делать слишком много вещей. Из такой ситуации можно сделать следующие выводы: 
> - Создавайте много мелких классов, с несколькими методами и одной ответственностью (см. также [принцип единой ответственности](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности))
> - Создавайте сервисы на базе этих маленьких классов

#### Используйте интерфейсы

Определяйте интерфейсы для ваших классов, как в самом бандле, так и в соответствующем библиотечном коде. Интерфейсы формально можно представить как контракты, которые подписываются между объектами. Класс, который реализует интерфейс как бы говорит: "не переживайте о том как я реализую те или иные функции, описанные в интерфейсе, вам достаточно знать как запросить меня выполнить их".

Традиционный пример с использованием только классов:

```php
class Translator
{
    public function trans($id, array $parameters = array())
    {
        ...
    }

    ... много других методов
}

class TranslationExtension
{
    private $translator;

    public function __construct(Translator $translator)
    {
        $this->translator = $translator;
    }

    public function trans($id, array $parameters = array())
    {
        return $this->translator->trans($id, $parameters);
    }
}
```

Определения сервисов для этих классов:

```xml
<service id="translator" class="...">
</service>

<service id="twig.extension.trans" class="...">
    <argument type="service" id="translator" />
</service>
```

Если разработчик захочет заменить сервис переводчика, ему нужно будет унаследоваться от существующего класса Translator для того, чтобы совпал тип агумента в конструкторе класса TranslationExtension.

```php
class MyTranslator extends Translator
{
    ...
}
```

```xml
<service id="my_translator" class="MyTranslator">
</service>
```

Но теперь класс MyTranslator наследует все методы из класса Translator, даже если они функционируют совершенно по другому.

Более правильным решением будет определить интерфейс для классов-переводчиков:

```php
interface TranslatorInterface
{
    public function trans($id, array $parameters = array());
}
```

Теперь, для того чтобы заменить переводчик нужно лишь реализовать его интерфейс:

```php
class MyTranslator implements TranslatorInterface
{
    public function trans($id, array $parameters = array())
    {
        // получаем перевод каким-то другим способом
        ...
    }
}
```

Наконец, любое упоминание типа Translator может быть заменено на TranslatorInterface:

```php
class TranslationExtension
{
    public function __construct(TranslatorInterface $translator)
    {
        ...
    }
}
```

Теперь ничто не стоит на пути замены существующего сервиса переводчика на сервис `my_translator`, удалив существующее определение, добавив новое определение, изменив класс существующего определения или определив алиас для translator - `my_translator`.

> #### Согласованные интерфейсы
> 
> При попытке определить, какие методы действительно должен содержать интерфейс, стремитесь к согласованному набору методов, который определенно будет принадлежать любому (будущему) классу, который будет реализовать интерфейс. 
#### Используйте конфигурацию бандла для замены сервисов

Как я отметил выше, теоретически вы можете заменить всё что угодно в контейнере на созданное вами. Имеется много способов добиться этого. Но все они не очень простые и не очень хорошие для дальнейшей поддержки. Наилучшим способом, который я видел, является возможность замены конкретных сервисов, предоставив ID сервиса в конфигурации бандла:

```php
# in /app/config/config.yml
matthias_message:
    # указывайте тут ID сервиса, который будет использоваться
    message_domain_manager: matthias_project.message_domain_manager
```

### Добавляйте точки расширения

Вы можете сделать поведение бандла настраиваемым, или же можете разрешить замену частей вашего бандла. Но вы также можете добавить возможности расширения возможностей бандла.

#### Метки (таги) сервисов

Одним из способов разрешить другим бандлам в приложении расширять возможности вашего бандла является использование тагов сервисов. Вы можете задуматься о способе регистрации типов для форм, который мог бы использоваться во всем приложении:
 
```xml
<service id="address_type" class="...">
    <tag name="form.type" alias="address" />
</service>
```

Используя проход компилятора вы можете найти все сервисы с необходимым тагом и выполнить с ними все что необходимо. Подробнее о тагах сервисов [читайте в документации](https://symfony.com/doc/current/service_container/tags.html)

#### События

События - замечательный инструмент для того, чтобы сделать хук в любой части вашего бандла. Вы можете использовать события для того, чтобы уведомить систему о том, что что-то произошло:

```php
$eventDispatcher->dispatch(
    'matthias_account.account_created',
    new AccountEvent($account)
);
```

Вы также можете использовать объект события для того, чтобы другие части приложения могли модифицировать (фильтровать) некоторые значения, как это делает, например, ядро Symfony, когда доставляет события ядра (см. также [Ранний ответ](#early_response))
