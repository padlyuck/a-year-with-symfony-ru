## Повторно используемый код должен иметь слабую связность

### Разделяйте код копании от кода продукта

В качестве Symfony разработчика вы можете:

- Работать на компанию.
- Работать на заказчиков (внутренних и внешних) для которых вы создаете web-приложения.

Когда вы начинаете работу над новым приложением, вы должны разместить код вашего проекта в директорию /src. Но перед тем как начать, добавьте туда еще 2 директории: /src/NameOfYourCompany и /src/NameOfTheProduct. Конечно же имена этих директорий будут также отражены в пространствах имен в классах, которые вы создадите для вашего проекта.

Когда бы вы ни начали работать над новой функцией вашего приложения - думайте о том, какую часть вы в теории могли бы повторно использовать, а какая часть уникальна для этого конкретного приложения. Даже если переиспользуемая часть никогда и не будет использована, качество такого кода будет существенно лучше. После начинайте создавать классы в пространстве имен вашей компании. Когда же вы реально почувствуете, что нужно сделать что-то специфичное именно для этого проекта, переходите работать в пространство имен продукта или же используйте принцип расширения (наследование, конфигурирование, слушатели событий и т.д.).

Написание переиспользуемого кода для вашей компании не означает, что этот код должен быть открытым (open source). Это всего лишь означает, что вы должны писать его так, как если бы он был таковым. Вы не обязаны создавать побочные проекты на основе кода компании (по крайней мере сразу). Вы можете разрабатывать его внутри проекта, над которым сейчас работаете, и возможно в дальнейшем подготовите его к повторному использованию в других ваших проектах. Подробнее о практических аспектах такого подхода почитайте в разделе [Управление зависимостями и контроль версий](#dependency_management_and_version_control)

> #### Связность между кодом компании и приложения
> 
> Когда вы строго следуете принципу разделения кода продукта и кода компании, то следует придерживаться нескольких правил, которые помогут вам сделать это разделение реально полезным (если же вы не следуете этим правилам - вам на самом деле нет смысла разделять пространства имен):
> 
> 1. Код компании может знать о или зависеть от другого кода компании.
> 2. Код компании не должен знать или зависеть от кода продукта.
> 3. Код продукта может знать или зависеть от другого кода этого продукта.
> 
> Первые два правила должны применяться строго: если вы будете следовать им - только тогда ваш код будет переиспользуемым или готовым для open source. Третье правило напротив, дает свободу: так как вы по определению не будете переиспользовать код, специфичный для продукта, вы можете делать его сколь угодно связанным 
> 

### Разделяйте код на "библиотечный" и "бандловый"

Когда вы пишите код не зависящий от Symfony или отдельных его компонентов, в этом случае вы должны разделять ваш код на "библиотечный" и "бандловый". Библиотечный код - это часть кода, которая более-менее самостоятельна (хотя могут иметься и внешние зависимости). Библиотечный код может быть использован разработчиком, который работает с Zend framework, или с микрофреймворком Silex (и это лишь малая часть примеров, которые можно привести). 

Бандловый код заменяет или расширяет некоторые классы из библиотечного кода, добавляя некоторые функции, специфичные для использования с Symfony. Он может определять конфигурацию бандла и его сервисы, для того чтобы экземпляры библиотечных классов были доступны в приложении. Фактически бандл просто делает библиотечный код доступным с минимумом усилий со стороны разработчиков, которые захотели бы использовать эту библиотеку в своих Symfony-приложениях.

Ниже перечислены элементы, которые должны быть внутри бандла:

- Контроллеры
- Расширения контейнера
- Определения сервисов
- Компиляторы (Compiler passes)
- Подписчики на события
- Классы, осведомленные о контейнере (Container-aware), которые расширяют базовые классы
- Классы типов для форм
- Конфигурация маршрутизатора
- Прочие метаданные
- ...

И этот список можно продолжать дальше, но его также можно и сократить. Если пораскинуть мозгами, то только первые несколько строк из списка выше реально специфичны для бандлов (т.е. используются только в контексте Symfony-приложений). Все же прочие элементы могут быть использованы в проектах, которые используют лишь некоторые из компонентов Symfony. Например, классы типов форм могут быть использованы в любом PHP проекте, который использует компонент Form.

> #### Примеры библиотечного и бандлового кода
>
> Имеется много хороших примеров такого разделения бандлов и библиотечного кода. Если вы посмотрите на код самого Symаony, вы можете увидеть применение подобного подхода: директория Component содержит все компоненты Symfony (это в наших терминах - "библиотечный код"), а директория Bundle содержит бандлы, которые связывают все классы вместе и предоставляют возможность конфигурирования их через аргументы конструкторов. Много отличных примеров такой стратегии можно найти в бандле FrameworkBundle (основополагающий бандл, когда он присутствует в проекте, мы можем говорить, что это Symfony-проект). 

### Уменьшайте связность с фреймворком

Вы можете пойти дальше и уменьшить связность с самим фреймворком или же с одним из его компонентов, что позволит сделать ваш код еще более пригодным для повтороного использования.

#### Слушатели событий (listeners) вместо подписчиков (subscribers)

Например, предпочтительно использование слушателей событий вместо подписчиков на события. Подписчики - это особые слушатели, которые реализуют интерфейс EventSubscriberInterface:

```php
use Symfony\Component\EventDispatcher\EventSubscriberInterface;

class SendConfirmationMailListener implements EventSubscriberInterface
{
    public static function getSubscribedEvents()
    {
        return array(
            AccountEvents::NEW_ACCOUNT_CREATED => 'onNewAccount'
        );
    }

    public function onNewAccount(AccountEvent $event)
    {
        ...
    }
}
```

Вы можете зарегистрировать подписчики типа рассмотренного выше, используя таг kernel.event_subscriber:

```xml
<service id="send_confirmation_mail_listener"
    class="SendConfirmationMailListener">
    <tag name="kernel.event_subscriber" />
</service>
```

При использовании такого подхода возникает несколько проблем:

1. Подписчик становится совершенно бесполезным, если в проекте не используется компонент Symfony EventDispatcher, хотя в самом подписчике может и не быть никакой Symfony-специфики.
2. Метод onNewAccount() получает объект класса AccountEvent, но нигде не определено, что такой объект может возникнуть только из события с именем AccountEvents::NEW_ACCOUNT_CREATED.

Таким образом, реализация слушателей в виде таких подписчиков не является приемлемой для переиспользуемого кода. Они связывают код с компонентом EventDispatcher. В данном случае лучше удалить использование интерфейса, удалить метод, реализующий интерфейс и зарегистрировать методы слушателя вручную, используя таг tag kernel.event_listener:

```xml
<service id="send_confirmation_mail_listener"
    class="SendConfirmationMailListener">
    <tag name="kernel.event_listener"
        event="new_account_created" method="onNewAccount" />
</service>
```

#### Аргументы конструктора вместо получения параметров из контейнера

Когда вы знаете, что необходимые вам параметры имеются в контейнере, вы можете внедрить контейнер целиком лишь для того чтобы получить эти параметры (это уже звучит как расточительство =):

```php
use Symfony\Component\DependencyInjection\ContainerInterface;

class SendConfirmationMailListener
{
    private $container;

    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    private function sendConfirmationMail()
    {
        $mailFrom = $this->container->getParameter('send_mail_from');

        ...
    }
}
```

И определение соответствующего сервиса будет таким:

```xml
<service id="send_confirmation_mail_listener"
    class="SendConfirmationMailListener">
    <argument type="service" id="service_container" />
</service>
```

Очевидно, что это очень плохо для переносимости сервиса: он может функционировать лишь в случае, если в приложении доступен контейнер Symfony. И ситуация даже хуже: даже если в проекте используется контейнер, никто не даст гарантий, что параметр send_mail_from будет в нем определен.

Таким образом, всегда внедряйте параметры контейнера в качестве аргументов конструктора, например так:

```xml
<service id="send_confirmation_mail_listener"
    class="SendConfirmationMailListener">
    <argument">%send_mail_from%</argument>
</service>
```

#### Аргументы конструктора вместо получения сервисов из контейнера

Также как и получение параметров из контейнера напрямую, использование контейнера для получения сервисов - это также плохая идея.

```php
class SendConfirmationMailListener
{
    private $container;

    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    private function sendConfirmationMail()
    {
        $mailer = $this->container->get('mailer');

        ...
    }
}
```

Целью внедрения всего контейнера обычно является быстродействие

> @dbykadorov: на мой взгляд спорное утверждение - так как внедрять немаленький контейнер в каждый сервис (как и я делал, когда только начинал писать на Symfony) - уже как минимум затратно по памяти.

Положим мы внедряем майлер напрямую в виде аргумента конструктора:

```php
class SendConfirmationMailListener
{
    private $mailer;

    public function __construct(\Swift_Mailer $mailer)
    {
        $this->mailer = $mailer;
    }
}
```

Теперь этот класс - слушатель события new_account_created. Когда бы слушатель не был бы создан, сервис майлера будет также инициализирован, даже если письмо будет отправлено лишь в некоторых случаях. Это займет некоторое время и некоторое количество системных ресурсов. И, хотя это действительно так, внедрение контейнера целиком для получения сервисов - это плохо, потому что:

1. Это связывает ваш код с особым типом контейнера (Symfony service container).
2. Предположение (потенциально неверное) что а) сервис майлера существует и б) он будет экземпляром 
\Swift_Mailer
3. Внутри сервиса вы сможете получить из контейнера все что угодно, даже больше чем следовало бы.

Собственно разработчики вдохновляются поступать таким образом, используя стандартный класс контроллера Symfony, который реализует ContainerAwareInterface. Имеются ситуации, когда целесообразно внедрить контейнер целиком, но в подавляющем большинстве случаев целый контейнер вам не будет нужен, нужен будет лишь конкретный сервис из него. И ваш класс должен быть связан лишь с этим сервисом, а еще лучше с его интерфейсом, но не с DI контейнером.

> @dbykadorov: я считаю что внедрение контейнера в сервисы - это один из самых частых и самых неприятных антипаттернов в Symfony приложениях. Происходит это от того, что при создании сервиса, не имеется четкого понимания, что он будет делать, и часто потом такие сервисы превращаются в GodObject'ы, которые и почту отправят и файл загрузят и для фото миниатюру создадут. 
>
> Также применение этого антипаттерна обусловлено засилием "толстых" контроллеров, которые любят создавать не очень ответственные разработчики. Такие контроллеры, как правило, наследуются от стандартного Symfony контроллера, который, как было сказано выше, осведомлен о контейнере (ContainerAware). Что означает доступность контейнера в любой момент, к чему разработчики привыкают и тянут эту привычку в создаваемые ими сервисы, что приводит к созданию "толстых" сервисов. О создании "тонких" контроллеров написано [ранее в главе III](#application_layers_thin_controllers). >
>
> Таким образом, если у вас появляется желание внедрить контейнер в ваш сервис - это значит, что у вас есть проблемы с дизайном приложения. Остановитесь, задумайтесь о той функции, которую должен выполнять этот сервис, и внедрите лишь то, что реально нужно. 

#### О производительности

Но что же будет с производительностью? Выше я написал, что тот путь, который я рекомендую (внедрение конкретного сервиса, а не контейнера), может вызвать оверхед, особенно в случаях, когда внедренный сервис может и не быть использован. Ну что же, у меня хорошие новости. Начиная с Symfony 2.3 вы можете не беспокоиться об этом. Вы можете добавить атрибут lazy="true" к определению сервиса, который может использоваться, или же не использоваться в вашем сервисе. В случае если атрибут lazy будет иметь значение "истина", [будет создан proxy-класс](http://symfony.com/doc/current/service_container/lazy_services.html). В результате вы можете внедрять зависимости в сервисы, но они будут полностью инициализироваться лишь тогда, когда вы вызовете один из их методов в первый раз. Я создал небольшое расширение - [LazyServicesBundle](https://github.com/matthiasnoback/LazyServicesBundle), которое позволяет вам назначать сервисы "ленивыми", отмечая те аргументы конструктора сервиса.

#### Контроллеры, не зависящие от фреймворка

В Symfony приложениях контроллеры, как правило, это те сущности, которые наиболее тесно связаны с фреймворком. Если вы всегда стремитесь к тому, чтобы минимизировать зависимость вашего кода от чего бы то ни было (как это делаю я), то контроллеры - это хорошие кандидаты для рефакторинга. Но сначала мы должны рассмотреть функции, которые выполняют большинство контроллеров:

- получение каких-то данных из запроса (параметр маршрута или атрибут запроса).
- получение каких-то сервисов для выполнения запрошенных действий.
- рендеринг шаблона с использованием переменных, полученных из сервиса...
- или добавление флеш-сообщений в сессию, для уведомления пользователя о результатах действия...
- или генерация URL на другую страницу, для перенаправления пользователя.

Все это должно быть выполнено, так как фреймворк ожидает от вас этого. Как вы вероятно уже поняли, все это делает ваши контроллеры очень тесно связанными с фреймворком. И это должно быть так!

Symfony контроллер не сможет нормально функционировать в другом приложении, которое не использует такие Symfony компоненты как Router, HttpKernel и HttpFoundation. И такие приложения я называю "Symfony-приложениями".

Поэтому в случае классов контроллеров вы можете пропустить все те шаги, что вы обычно делаете для уменьшения связности. Поэтому не стоит отказываться от наследования ваших контроллеров от стандартного Symfony-контроллера. Он может быть очень полезен, так как имеет много полезных методов для выполнения регулярно возникающих задач (например, createForm(), generateUrl(), createNotFoundException(), redirectToRoute() и т.д.).

Также вы не должны определять ваши контроллеры в виде сервисов. Они не будут повторно использованы в виде сервисов. Тем не менее, временами я начинаю думать, что это было бы неплохой идеей - иметь полный контроль над процессом создания контроллера, который в противном случае создается "магически" при помощи ControllerResolver, после чего - еще более магическим способом - в контроллер внедряется контейнер, если этот контроллер реализует ContainerAwareInterface (подробнее об этом читайте в разделе [всё, что может быть контроллером](#all_the_things_controller_can_be)).

Последнее замечание, перед тем, как вы радостно начнете привязывать ваши контроллеры к фреймворку: вы все еще должны стремиться делать ваши контроллеры маленькими, насколько это возможно. Когда вы входите в контроллер, вы должны быстро перевести фокус из контроллера в некоторый сервис, который выполнит всю необходимую работу. Смотрите также раздел [Тонкие контроллеры](#application_layers_thin_controllers).

#### Тонкие команды

Создавать консольные команды в Symfony очень просто и, как правило, рекомендуется для выполнения некоторых специфичных задач для вашего бандла, с использованием командной строки. В то же время, команды должны рассматриваться также как и [контроллеры](#application_layers_thin_controllers): они должны быть тонким слоем между входными параметрами, предоставленными пользователем и сервисом, который используется для выполнения задачи и получения результата, который должен увидеть пользователь.

Таким образом, в идеальном случае, метод execute() должен содержать лишь проверки входных параметров, получение необходимого сервиса из контейнера и вызов некоторого его метода.

```php
namespace Matthias\BatchProcessBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class BatchProcessCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this->setName('matthias:batch-process');
    }

    protected function execute(
        InputInterface $input,
        OutputInterface $output
    ) {
        $processor = $this->getContainer()->get('batch_processor');

        foreach (array('main', 'sub', 'special') as $collection) {
            $processor->process($collection);
        }
    }
}
```

Если вам нужно сделать что-то большее внутри команды, перенесите как можно больше функций в специфичные сервисы.

Такой подход упростит повторное использование кода команды, даже при использовании другой библиотеки для выполнения команд, а также поможет тестировать ваш код, который "реально делает дело", так как тестировать код внутри команды намного сложнее (с учетом меньшей изоляции), чем тестирование кода в обычном PHP классе.

Вынесение кода из класса команды сделает генерацию вывода команды в консоль более сложной задачей. Но имеется и весьма интересное решение для этой задачи: [AOP - аспектно ориентированное программирование](http://php-and-symfony.matthiasnoback.nl/2013/07/symfony2-rich-console-command-output-using-aop/).

#### Окружение

Symfony имеет весьма удобный способ разделения и последовательного включения конфигурации бандла для различных окружений. Эти окружения, по принятому соглашению, называются dev, test и prod. Однако, эти значения в общем случае могут быть произвольными. Это даже не константы класса, но это первый аргумент, используемый для создания экземпляра ядра фронт-контроллера в /web:

```php
// in /web/app_dev.php
$kernel = new AppKernel('dev', true);
```

Таким образом, вы никогда не должны зависеть от имени окружения, или же хардкодить его внутри любой части вашего кода. Вот такой код вы никогда не должны писать:

```php
class SendConfirmationMailListener
{
    private $environment;

    public function __construct($environment)
    {
        $this->environment = $environment;
    }

    private function sendConfirmationMail()
    {
        if ($this->environment === 'dev') {
            // always send the mail to matthiasnoback@gmail.com :)
        }
    }
}
```

Любая модификация поведения, зависимая от окружения приложения должна иметь место на уровне конфигурации вашего бандла, но даже в этом случае она должна быть неявной, так как другой разработчик может использовать совсем другие имена окружений. Фактически, когда вы копируете все из `config_dev.yml` `в config_prod.yml`, ваше продуктовое окружение будет выглядеть и работать как окружение для разработки.
