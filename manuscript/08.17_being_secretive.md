## Быть скрытным

В многих случаях взлом системы подразумевает получение масимально возможного понимания того как эта система
работает, понимать её уязвимые, а следовательно пригодные для взлома части. Таким образом вам нужно быть 
весьма осторожными в плане того, что вы вообще показываете во вне.

### Маскируйте ошибки аутентификации

Документация Symfony содержит очень плохой с точки зрения безопасности пример, когда переменная с текстом исключения 
показывается на форме аутентификации (тут переменная error это экземпляр объекта Exception):

{lang="twig"}
~~~~~~~~~~~~~
{% if error %}
    <div>{{ error.message }}</div>
{% endif %}
~~~~~~~~~~~~~

> @dbykadorov
>
> Если мне не изменяет память, с версии 2.6 документация скорректирована в соответствии с изменениями 
> компонента Security и не является таким откровенным фейлом. Маттиас вероятно имеет в виду эту часть документации: 
> [Как использовать традиционную форму логина](http://symfony.com/doc/master/security/form_login_setup.html)

Сразу хочется настроить вас на "мудрое использование сообщений об исключениях", так как они могут содержать
очень важную с точки зрения безопасности информацию. И так скорее всего и будет, как я неоднократно убеждался.
Иногда, когда вы захотите отобразить сообщение исключения напрямую, в шаблон может быть помещена информация об
ошибке работы с базой данных, включая описание схемы данных, что совершенно небезопасно, так как даёт потенциальному
злоумыленнику информацию о внутреннем устройстве вашей схемы данных.

К счасттью, все исключения, унаследованные от AuthenticationException имеют метод getMessageKey. При 
вызове этого метода вы получите простое сообщение об ощибке, без каких-то критичных деталей о самом
исключении. Это будет простое сообщение, типа "Неверные учетные данные." или "Аутентификация не может быть
выполнена вследствие системных проблем.".

Таким образом, правильный шаблон формы логина, который отображает ошибки будет таким:

{lang="twig"}
~~~~~~~~~~~~~
{% if error %}
    <div>{{ error.messageKey }}</div>
{% endif %}
~~~~~~~~~~~~~

### Предотвращайте отображение исключений

Если в вашем приложении имеются такие места, где вы хотите использовать исключения для отображения
сообщений об ошибках пользователям, я могу вам предложить для этого следующие стратегии. Вы можете использовать
приём описанный выше (использовать метод `getMessageKey`, который будет возвращать сообщение об ошибке, которое
можно без опаски показывать пользователям). Вы также можете обернуть низкоуровневые исключения более
высокоуровневыми и устанавливать новое сообщение об ошибке, которое можно показывать пользователям. Вам
также надо побеспокоиться о базовых низкоуровневых исключениях, которые могут возникать на глубоких уровнях
абстракции и которые вы по ошибке можете принять за одно из собтсвенных исключений. Также вы можете помечать
некоторые исключения как безопасные для отображения их пользотвателям, фильтруя их:

{lang="php"}
~~~~~~~~~~~~
$error = null;

try {
    // делаем что-то оооччень опасное
    ...
} catch (SomeSpecificException $exception) {
    $error = $exception;
} catch (\Exception $previous) {
    // любое другое неожиданное исключение
    $error = new GenericException('An error occurred', null, $previous);
}

// $error теперь можно использовать без опаски
~~~~~~~~~~~~

При таком подходе есть одна проблема. Дело в том, что стандартный обработчик ислючений Symfony (который также
логгирует их, при включенном журналировании), не будет уведомлён о реально неожиданном исключении. Так как это
как правило симптом проблем где-то на глубоких уровнях приложения, такое поведение весьма нежелательно. Следовательно,
в большинстве ситуаций нужно отлавливать только несколько известных приложению исключений, и позволять перехватывать
остальные встроенным в Symfony процедурам.

### Настройте страницы ошибок

Когда "нормальное" исключение, указывающее на системную ошибку, перехватывается стандартным обработчиком исключений,
вы должны быть уверены, что ничего лишнего не будет показано пользователю. Любая информация о системе, которая 
попадёт к пользователю, может быть использована для определения стратегии её взлома. Вам необходимо
[создать ваши собственные страницы ошибок](http://symfony.com/doc/master/controller/error_pages.html), которые
будут выполнены в стиле всего остального приложения. Никогда не показывайте никакой сгенерированной информации
о проблеме, никаких stack trace (низкоуровневый отчёт о хотде выполнения приложения до момента возникновения ошибки)!
Проблемы должны автоматически логгироваться, вы также можете настроить отправку ошибок на email, например
[настроив Monolog](http://symfony.com/doc/master/logging/monolog_email.html) или воспользовавшись любым другим 
инструментом журналирования, которые могут отправлять вам уведомления, когда что-то идёт не так. Последний вариант 
может быть даже более предпочтительным, так как приложение может придти в такое состояние, когда оно само не
сможет отправлять уведомления.

### Не сообщайте ничего определённого о конфиденциальных данных

Проблемы аутентификации по большей части покрываются Security компонентом Symfomy. Тем не менее имеется
ряд узких мест, которые при стечении обстоятельств могут привести к раскрытию конфиденциальной 
информации о ваших пользователях или системе. Когда ваша система тем или иным образом даёт доступ к информации 
о том, какие пользователи в ней зарегистрированы, то она уязвима к т.н. "харвестингу" (т.е. к автоматизированному
сбору данных пользователей, возможно конфиденциальных). Ниже приведены несколько примеров дизайна, которые допускают
утечку информации о пользователях.

1. Пользователь может сбросить свой пароль на странице "Забыл пароль", которая содержит форму с полем Email.
Когда пользователь укзазывает свой email и отправляет форму, система ищет учётную запись пользователя и 
генерирует ссылку на восстановление пароля, которая отправляется на email, указанный пользователем. После отправки
формы страница сообщает что-то похожее на "Мы выслали письмо с инструкциями по восстановлению пароля на указанный 
адрес". Проблема в данном случае заключается в следующем: если кто-то пытается собирать email-адреса ваших 
пользователей, он теперь знает, зарегистрирован ли у вас в системе конкретный адрес или нет.

2. Та же ситуация, что и в примере выше, но теперь сообщение такое: "Если email принадлежит одному из наших
пользователей, то мы выслали письмо с инструкциями по восстановлению пароля на него.". Это сообщение выглядит более
безопасно, но злоумышленник может делать определённые выводы на основании скорости выполнения запросов (если
email отправляется - запрос будет выполняться дольше). Это называется "атакой по времени выполнения"

3. Когда пользователь вошёл в систему, он имеет возможность изменения email адреса, с использованием формы
с одним полем - Email. После отправки формы система изменяет адрес или отображает сообщение "Такой адрес уже
используется". Опять - мы можем определять зарегистрирован ли в системе пользователь с конкретным адресом, даже
если это конфиденциальная информация.

Наилучшим решением по предотвращению харвестинга будет неопределённость в сообщениях касательно пользовательских 
данных: никогда не говорите что есть точное совпадение, что вы отправили email и т.д. Вы также должны быть уверены, 
что это нельзя определить по длительности выполнения запросов.

В случае с проблемой номер 3 можно предпринять следующее:

1. Если вы разрешаете пользователю смену email адреса - не сохраняйте его сразу.

2. Отправьте на новый адрес email с сылкой, по клику на которую пользователь сможет подтвердить запрос
на смену email адреса.

3. После подтверждения смены адреса, обновите данные о новом email адресе пользователя.

> #### @dbykadorov: будьте параноиком
>
> Эту часть надо было бы назвать "быть параноиком" =) Так как в вопросах обеспечения безопасности никогда не бывает
> "черезчур". В решении проблемы 3 я тоже вижу определённые недостатки. Проблему харвестинга она допустим решает.
> Но что если пользователь, email которого подвергается атаке, получив непонятное письмо со ссылкой просто кликнет
> на неё, не особо задумывась (или случайно). В этом случае он может лишиться своего аккаунта. И тут бы наверное 
> можно было бы сказать "сам виноват", но если вы дорожите своими пользователями, я бы посоветовал использовать
> какой-нибудь альтернативный способ смены адреса.
>
> Например, вместо ссылки, которая сразу активирует действие, можно присылать код, введя который в личном 
> кабинете (лишь у того пользователя, который запросил смену адреса!) можно подтвердить смену email адреса.
> Более того, код можно ограничить по времени действия. И это, вероятно, ещё не самый безопасный вариант.
>
> Так что, если вы действительно заботитесь о безопасности, не доверяйте никому, всё подвергайте сомнению, будьте на
> шаг впереди! 