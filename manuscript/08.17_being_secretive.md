## Быть скрытным

В многих случаях взлом системы подразумевает получение максимально возможного понимания того как эта система работает, понимать её уязвимые, а следовательно пригодные для взлома части. Таким образом вам нужно быть весьма осторожными в плане того, что вы вообще показываете во вне.

### Маскируйте ошибки аутентификации

Документация Symfony содержит очень плохой с точки зрения безопасности пример, когда переменная с текстом исключения показывается на форме аутентификации (тут переменная error это экземпляр объекта Exception):

```twig
{% if error %}
    <div>{{ error.message }}</div>
{% endif %}
```

> @dbykadorov
>
> Если мне не изменяет память, с версии 2.6 документация скорректирована в соответствии с изменениями компонента Security и не является таким откровенным фейлом. Маттиас вероятно имеет в виду эту часть документации: [Как использовать традиционную форму логина](http://symfony.com/doc/master/security/form_login_setup.html)


Сразу хочется настроить вас на "мудрое использование сообщений об исключениях", так как они могут содержать очень важную с точки зрения безопасности информацию. И так скорее всего и будет, как я неоднократно убеждался. Иногда, когда вы захотите отобразить сообщение исключения напрямую, в шаблон может быть помещена информация об ошибке работы с базой данных, включая описание схемы данных, что совершенно небезопасно, так как даёт потенциальному злоумышленнику информацию о внутреннем устройстве вашей схемы данных.

К счастью, все исключения, унаследованные от AuthenticationException имеют метод getMessageKey. При вызове этого метода вы получите простое сообщение об ошибке, без каких-то критичных деталей о самом исключении. Это будет простое сообщение, типа "Неверные учетные данные." или "Аутентификация не может быть выполнена вследствие системных проблем.".

Таким образом, правильный шаблон формы логина, который отображает ошибки будет таким:

```twig
{% if error %}
    <div>{{ error.messageKey }}</div>
{% endif %}
```

### Предотвращайте отображение исключений

Если в вашем приложении имеются такие места, где вы хотите использовать исключения для отображения сообщений об ошибках пользователям, я могу вам предложить для этого следующие стратегии. Вы можете использовать приём описанный выше (использовать метод `getMessageKey`, который будет возвращать сообщение об ошибке, которое можно без опаски показывать пользователям). Вы также можете обернуть низкоуровневые исключения более высокоуровневыми и устанавливать новое сообщение об ошибке, которое можно показывать пользователям. Вам также надо побеспокоиться о базовых низкоуровневых исключениях, которые могут возникать на глубоких уровнях абстракции и которые вы по ошибке можете принять за одно из собственных исключений. Также вы можете помечать некоторые исключения как безопасные для отображения их пользователям, фильтруя их:

```php
$error = null;

try {
    // делаем что-то оооччень опасное
    ...
} catch (SomeSpecificException $exception) {
    $error = $exception;
} catch (\Exception $previous) {
    // любое другое неожиданное исключение
    $error = new GenericException('An error occurred', null, $previous);
}

// $error теперь можно использовать без опаски
```

При таком подходе есть одна проблема. Дело в том, что стандартный обработчик исключений Symfony (который также логгирует их, при включенном журналировании), не будет уведомлен о реально неожиданном исключении. Так как это как правило симптом проблем где-то на глубоких уровнях приложения, такое поведение весьма нежелательно. Следовательно, в большинстве ситуаций нужно отлавливать только несколько известных приложению исключений, и позволять перехватывать остальные встроенным в Symfony процедурам.

### Настройте страницы ошибок

Когда "нормальное" исключение, указывающее на системную ошибку, перехватывается стандартным обработчиком исключений, вы должны быть уверены, что ничего лишнего не будет показано пользователю. Любая информация о системе, которая попадёт к пользователю, может быть использована для определения стратегии её взлома. Вам необходимо [создать ваши собственные страницы ошибок](http://symfony.com/doc/master/controller/error_pages.html), которые будут выполнены в стиле всего остального приложения. Никогда не показывайте никакой сгенерированной информации о проблеме, никаких stack trace (низкоуровневый отчёт о ходе выполнения приложения до момента возникновения ошибки)! Проблемы должны автоматически логгироваться, вы также можете настроить отправку ошибок на email, например [настроив Monolog](http://symfony.com/doc/master/logging/monolog_email.html) или воспользовавшись любым другим инструментом журналирования, которые могут отправлять вам уведомления, когда что-то идёт не так. Последний вариант может быть даже более предпочтительным, так как приложение может прийти в такое состояние, когда оно само не сможет отправлять уведомления.

### Не сообщайте ничего определённого о конфиденциальных данных

Проблемы аутентификации по большей части покрываются Security компонентом Symfony. Тем не менее имеется ряд узких мест, которые при стечении обстоятельств могут привести к раскрытию конфиденциальной информации о ваших пользователях или системе. Когда ваша система тем или иным образом даёт доступ к информации о том, какие пользователи в ней зарегистрированы, то она уязвима к т.н. "харвестингу" (т.е. к автоматизированному сбору данных пользователей, возможно конфиденциальных). Ниже приведены несколько примеров дизайна, которые допускают утечку информации о пользователях.

1. Пользователь может сбросить свой пароль на странице "Забыл пароль", которая содержит форму с полем Email. Когда пользователь указывает свой email и отправляет форму, система ищет учётную запись пользователя и генерирует ссылку на восстановление пароля, которая отправляется на email, указанный пользователем. После отправки формы страница сообщает что-то похожее на "Мы выслали письмо с инструкциями по восстановлению пароля на указанный адрес". Проблема в данном случае заключается в следующем: если кто-то пытается собирать email-адреса ваших пользователей, он теперь знает, зарегистрирован ли у вас в системе конкретный адрес или нет.

2. Та же ситуация, что и в примере выше, но теперь сообщение такое: "Если email принадлежит одному из наших пользователей, то мы выслали письмо с инструкциями по восстановлению пароля на него.". Это сообщение выглядит более безопасно, но злоумышленник может делать определённые выводы на основании скорости выполнения запросов (если email отправляется - запрос будет выполняться дольше). Это называется "атакой по времени выполнения"

3. Когда пользователь вошёл в систему, он имеет возможность изменения email адреса, с использованием формы с одним полем - Email. После отправки формы система изменяет адрес или отображает сообщение "Такой адрес уже используется". Опять - мы можем определять зарегистрирован ли в системе пользователь с конкретным адресом, даже если это конфиденциальная информация.

Наилучшим решением по предотвращению харвестинга будет неопределённость в сообщениях касательно пользовательских данных: никогда не говорите что есть точное совпадение, что вы отправили email и т.д. Вы также должны быть уверены, что это нельзя определить по длительности выполнения запросов.

В случае с проблемой номер 3 можно предпринять следующее:

1. Если вы разрешаете пользователю смену email адреса - не сохраняйте его сразу.

2. Отправьте на новый адрес email с ссылкой, по клику на которую пользователь сможет подтвердить запрос на смену email адреса.

3. После подтверждения смены адреса, обновите данные о новом email адресе пользователя.

> #### @dbykadorov: будьте параноиком
>
> Эту часть надо было бы назвать "быть параноиком" =) Так как в вопросах обеспечения безопасности никогда не бывает "чересчур". В решении проблемы 3 я тоже вижу определённые недостатки. Проблему харвестинга она допустим решает. Но что если пользователь, email которого подвергается атаке, получив непонятное письмо со ссылкой просто кликнет на неё, не особо задумываясь (или случайно). В этом случае он может лишиться своего аккаунта. И тут бы наверное можно было бы сказать "сам виноват", но если вы дорожите своими пользователями, я бы посоветовал использовать какой-нибудь альтернативный способ смены адреса.
>
> Например, вместо ссылки, которая сразу активирует действие, можно присылать код, введя который в личном кабинете (лишь у того пользователя, который запросил смену адреса!) можно подтвердить смену email адреса. Более того, код можно ограничить по времени действия. И это, вероятно, ещё не самый безопасный вариант.
>
> Так что, если вы действительно заботитесь о безопасности, не доверяйте никому, всё подвергайте сомнению, будьте на шаг впереди!
