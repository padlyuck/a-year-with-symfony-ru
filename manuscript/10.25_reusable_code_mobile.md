## Повторно используемый код должен быть легко переносимым

Главной характеристикой переносимого (мобильного) кода, является то, можете ли вы не прилагая 
усилий перенести его в другое приложение. После установки такого кода в другое приложение, вы
поймете преносим ли код если:

- вы можете исправить баги в коде, даже если ранее он был скопирован не один раз
- код не падает, если библиотека, компонент, бандл или расширение PHP, которые он использует,
не присутствуют в новом проекте
- вы можете его легко настроить на использование другой базы данных, в том числе и на использование
другого типа базы данных
- код не падает если отсутствуют какие-то таблицы или какие-то конкретные коллекции (данных)
- код не падает если он помещен не в ту же самую директорию в новом проекте

{#dependency_management_and_version_control}
### Управление зависимостями и контроль версий

Первые две характеристики мобльности кода относятся к инфраструктуре: при повторном использовании ваш
код не должен тупо копироваться - он должен быть под версионным контролем, так что каждый багфикс
может быть легко применен ко всем копиям вашего кода.

Вы можете добиться этого, используя внешние или под-модули (зависит от типа используемой вами системы
контроля версий), но для PHP лучшим выбором будет использовать [Composer](http://getcomposer.org/).
Каждая часть вашего кода, которую вы хотите сделать доступной для всех ваших проектов, должна иметь
свой собственный репозиторий. В случае, если вы хотите использовать код самостоятельно (или внути вашей компании) -
захостите репозиторий приватно на [GitHub](https://github.com/), [Bitbucket](https://bitbucket.org/) или
подобных сервисах. Если вы захотите сделать ваш код открытым, перейти в Open Source, то GitHub будет
самым подходящим местом для этого.

В обоих случаях вам нужен файл composer.json. Этот файл прежде всего превратит ваш код в нечто цельное - в пакет.
В файле composer.json вы можете определять зависимости (версия PHP, расширения PHP, другие библиотеки), можете
указать автозагрузчику где искать классы и функции, можете добавить информацию о себе, о пакете, указать
метки, которые описывают ваш проект.

Например, вот слегка модифицированный файл composer.json из библиотеки knplabs/gaufrette:

{lang="json"}
~~~~~~~~~~~~
{
    "name": "knplabs/gaufrette",
    "type": "library",
    "description": "Library that provides a filesystem abstraction layer",
    "keywords": ["file", "filesystem", "media", "abstraction"],
    "minimum-stability": "dev",
    "homepage": "http://knplabs.com",
    "license": "MIT",
    "authors": [
        {
            "name": "KnpLabs Team",
            "homepage": "http://knplabs.com"
        }
    ],
    "require": {
        "php": ">=5.3.2"
    },
    "require-dev": {
        "amazonwebservices/aws-sdk-for-php": "1.5.*",
        "phpspec/phpspec2": "dev-master",
        "rackspace/php-cloudfiles": "*",
        "doctrine/dbal": ">=2.3",
        "dropbox-php/dropbox-php": "*",
        "herzult/php-ssh": "*",
        "phpunit/phpunit": "3.7.*"
    },
    "suggest": {
        "knplabs/knp-gaufrette-bundle": "*",
        "dropbox-php/dropbox-php": "to use the Dropbox adapter",
        "amazonwebservices/aws-sdk-for-php": "to use the Amazon S3 adapter",
        "doctrine/dbal": "to use the Doctrine DBAL adapter",
        "ext-zip": "to use the Zip adapter"
    },
    "autoload": {
        "psr-0": { "Gaufrette": "src/" }
    }
}
~~~~~~~~~~~~

Список зависимостей (секции require*) должен полностью покрывать потребности основной функциональности вашего пакета.
Если пакет содержит классы, которые могут быть использованы по желанию и которые имеют дополнительные
зависимости, указывайте их в секции suggest. Если вы написали тесты для этих классов (вы ведь должны были это сделать,
не так ли?) - убедитесь, что в списке зависимостей вы указали и фреймворк для тестирования (в секции require-dev), 
чтобы ваши тесты могли бы быть выполнены кем угодно и ни один тест не был бы завален или пропущен из-за неуказанной
зависимости.

#### Репозитории пакетов

Если репозиторий содержит файл composer.json в его корневой директории, вы можете оформить его в виде пакета 
на сайте [Packagist](https://packagist.org/). Это сделает ваш код открытым для всех, кому он потребуется.
Если же вы не хотите этого, вы можете поднять свой собственный приватный репозиторий пакетов с использованием
[Satis](https://github.com/composer/satis). Это будет полезно при использовании вашего кода в различных
ваших проектах или в проектах вашей компании.

После того как composer.json, основанный на том что реально требуется для вашего кода, был создан и зарегистрирован 
как пакет с использованием Packagist или Satis, вы можете установить этот пакет в любой из ваших проектов, 
выполнив команду:

~~~~~~~~~
composer.phar require [name-of-package] 0.1.*
~~~~~~~~~

Теперь ваш код удовлетворяет второму признаку переносимого кода: после его установки он не будет падать и сбоить
из-за отсутствующих зависимостей.

### Жесткая привязка к хранилищу (базе данных)

#### Сущности с автоматическим сопоставлением (auto-mapped)

Одной из самых больших проблем со сторонними бандлами являются сущности (предназначенные для маппинга) с базой
данных, котрые они определяют (например, с использованием аннотаций) и которые размещаются в директории Entity 
внутри бандла. Это автоматически делает эти сущности доступными внутри вашего проекта. Это может показаться
полезным, но в большинстве ситуаций это не так: в этом случае вы не можете выбрать нужную схему, добавить
необходимые вам поля или даже отказать от использования этих сущностей и переопределить модель, например,
с использованием документов MongoDB.

Если бандл принуждает к использованию специфичного хранилища, как описано выше, вы узнаете об этом как только
выполните команду типа doctrine:schema:update: не спрашивая вашего разрешения, внезапно, будут созданы все таблицы 
для сущностей из стороннего бандла потому что вы его активировали, и все его сущности были автоматически
зарегистрированы в вашем проекте. Та же проблема возникает если выполнить команду doctrine:migrations:diff.
В этом случае скрипт миграции будет сгенерирован для таблиц, которые вам возможно и не нужны.

#### Модели, не привязанные к хранилищу

Правильным способом определения моделей ваших бандлов является создание базовых классов. Эти базовые классы
должны содержать get*, set* и прочие методы для модификации или проверки состояния объекта.
Они должны иметь защищенные (protected) свойства (по умолчанию свойства объявляюся приватными, но в этом случае
дочерние класы не будут иметь к ним доступа) и не должны содержать никаких аннотаций для маппинга.
Такие модели, не привязанные к хранилищу должны быть размещаться внутри бандла в директории Model и
не должны содержать кода, специфичного для их менеджера моделей (например, для Doctrine это EntityManager 
или DocumentManager).

{lang="php"}
~~~~~~~~~~~~
namespace Matthias\MessageBundle\Model;

class Message
{
    protected $body;

    public function getBody()
    {
        return $this->body;
    }
}
~~~~~~~~~~~~

Такой подход даст возможность разработчикам, которые захотят использовать ваш бандл, унаследовать базовый класс
и определить любые необходимые метаданные, необходимые для маппинга данных к нужному типы базы данных:

{lang="php"}
~~~~~~~~~~~~
namespace Matthias\ProjectBundle\Entity;

use Matthias\MessageBundle\Model\Message as BaseMessage;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class Message extends BaseMessage
{
    /**
     * @ORM\Column(type="text")
     */
    protected $body;

    // Application specific data:

    /**
     * @ORM\Column(type="integer")
     */
    protected $upVotes;

    /**
     * @ORM\Column(type="integer")
     */
    protected $downVotes;
}
~~~~~~~~~~~~

Как вы можете видеть, такой подход позволяет добавлять дополнительные поля, которых не было в базовой сущности.
Также убедитесь, что ваш бандл имеет настройку для указания пользовательского класса модели:

{lang="php"}
~~~~~~~~~~~~
matthias_message:
    message_class: Matthias\ProjectBundle\Entity\Message
~~~~~~~~~~~~

> #### Классы моделей являются библиотечным кодом (фактически)
> 
> Как было предложено ранее, вам нужно отделять любой код, который не специфичен для Symfony-приложения
> в отдельные библиотеки. Тоже применимо и для классов моделей. Они не должны быть частью бандла, а
> должны быть частью библиотеки.

#### Менеджеры объектов

Даже если вы определили модели не зависящие от хранилища, это не значит, что ваш бандл должен такде
быть независимым от него. Вы лишь должны позаботиться о том, что пользователи вашего приложения должны
иметь возможность реализации собственных методов работы с хранилищем и соответственно возможность
отключить стандартный, который реализовали вы. Вы можете воспользоваться 
[паттерном Стратегия для загрузки сервисов](#strategy_pattern_loading_exclusive_services), а также используя 
алиасы.

Также вы должны предоставить возможность конфигурирования имен менеджеров сущностей, документов и т.д.
Например, DoctrineORM позволяет пользователям определять различные менеджеры для различных классов сущностей.
Таким образом даже если менеджер сущностей, используемый по умолчанию, в большинстве случаев будет правильным,
вы должны добавить ключ конфигурации для его переопределия в конфигурации вашего бандла.

### Жесткая привязка к файловой системе

Убедитесь, что ваш бандл не содержит жесткой привязки к файловой системе за пределами вашего бандла.
Вы можете более-менее быть уверены в том, что все что находится в корневой директории бандла - под вашим
контролем, но все что находится вовне - директории vendors, web или любые другие директории - должно
считаться неизвестным. Фактически, так и есть: когда речь заходит о структуре директорий, ничто не может
быть постоянным при использовании Symfony. Есть только "значения по умолчанию".

Любая ссылка на что-то вне домашней директори бандла должна быть частью конфигурации и следовательно 
настраиваемой через config.yml. Вы также можете предлагать значения по умолчанию, чтобы выш бандл мог заработать
"из-коробки" при его установке в стандартный Symfony проект. Обычно для подобных настроек используется скалярный 
нод со значением по умолчанию в дереве конфигурации. Затем эта конфигурация будет обработана в методе load() в
классе расширения вашего бандла и будет определен параметр для нее. Позднее этот параметр может быть внедрен,
например, в качестве аргумента конструктора. См. также раздел [Определяем параметры в расширениях 
контейнера](#define_parameters_in_container_extension).

#### Использование файловой системы

Когда вашема бандлу необходимо использовать для хранения данных помимо СУБД что-то еще, например, хранить
файлы, загруженные пользователями, постарайтесь сделать бандл независимым от файловой системы. Так как не
каждое приложение имеет доступ на запись к файловой системе на сервере, вы можете использовать слой абстракции
файловой системы, как например [Gaufrette](https://github.com/KnpLabs/Gaufrette). Эта библиотека имеет адаптеры для 
различных типов файловых систем (локальных и удаленных), и ваши сервисы даже не будут (и не должны) замечать, когда
эти адаптеры переключаются. Также имеется [GaufretteBundle](https://github.com/KnpLabs/KnpGaufretteBundle), который 
упрощает процесс интеграции этой библиотеки с вашими Symfony бандлами.