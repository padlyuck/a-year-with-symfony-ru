## Повторно используемый код должен быть легко переносимым

Главной характеристикой переносимого (мобильного) кода, является то, можете ли вы не прилагая усилий перенести его в другое приложение. После установки такого кода в другое приложение, вы поймете преносим ли код если:

- вы можете исправить баги в коде, даже если ранее он был скопирован не один раз
- код не падает, если библиотека, компонент, бандл или расширение PHP, которые он использует, не присутствуют в новом проекте
- вы можете его легко настроить на использование другой базы данных, в том числе и на использование другого типа базы данных
- код не падает если отсутствуют какие-то таблицы или какие-то конкретные коллекции (данных)
- код не падает если он помещен не в ту же самую директорию в новом проекте

{#dependency_management_and_version_control}
### Управление зависимостями и контроль версий

Первые две характеристики мобильности кода относятся к инфраструктуре: при повторном использовании ваш код не должен тупо копироваться - он должен быть под версионным контролем, так что каждый багфикс может быть легко применен ко всем копиям вашего кода.

Вы можете добиться этого, используя внешние или под-модули (зависит от типа используемой вами системы контроля версий), но для PHP лучшим выбором будет использовать [Composer](http://getcomposer.org/). Каждая часть вашего кода, которую вы хотите сделать доступной для всех ваших проектов, должна иметь свой собственный репозиторий. В случае, если вы хотите использовать код самостоятельно (или внутри вашей компании) - захостите репозиторий приватно на [GitHub](https://github.com/), [Bitbucket](https://bitbucket.org/) или подобных сервисах. Если вы захотите сделать ваш код открытым, перейти в Open Source, то GitHub будет самым подходящим местом для этого.

В обоих случаях вам нужен файл composer.json. Этот файл прежде всего превратит ваш код в нечто цельное - в пакет. В файле composer.json вы можете определять зависимости (версия PHP, расширения PHP, другие библиотеки), можете указать автозагрузчику где искать классы и функции, можете добавить информацию о себе, о пакете, указать метки, которые описывают ваш проект.

Например, вот слегка модифицированный файл composer.json из библиотеки knplabs/gaufrette:

```json
{
    "name": "knplabs/gaufrette",
    "type": "library",
    "description": "Library that provides a filesystem abstraction layer",
    "keywords": ["file", "filesystem", "media", "abstraction"],
    "minimum-stability": "dev",
    "homepage": "http://knplabs.com",
    "license": "MIT",
    "authors": [
        {
            "name": "KnpLabs Team",
            "homepage": "http://knplabs.com"
        }
    ],
    "require": {
        "php": ">=5.3.2"
    },
    "require-dev": {
        "amazonwebservices/aws-sdk-for-php": "1.5.*",
        "phpspec/phpspec2": "dev-master",
        "rackspace/php-cloudfiles": "*",
        "doctrine/dbal": ">=2.3",
        "dropbox-php/dropbox-php": "*",
        "herzult/php-ssh": "*",
        "phpunit/phpunit": "3.7.*"
    },
    "suggest": {
        "knplabs/knp-gaufrette-bundle": "*",
        "dropbox-php/dropbox-php": "to use the Dropbox adapter",
        "amazonwebservices/aws-sdk-for-php": "to use the Amazon S3 adapter",
        "doctrine/dbal": "to use the Doctrine DBAL adapter",
        "ext-zip": "to use the Zip adapter"
    },
    "autoload": {
        "psr-0": { "Gaufrette": "src/" }
    }
}
```

Список зависимостей (секции require*) должен полностью покрывать потребности основной функциональности вашего пакета. Если пакет содержит классы, которые могут быть использованы по желанию и которые имеют дополнительные зависимости, указывайте их в секции suggest. Если вы написали тесты для этих классов (вы ведь должны были это сделать, не так ли?) - убедитесь, что в списке зависимостей вы указали и фреймворк для тестирования (в секции require-dev), чтобы ваши тесты могли бы быть выполнены кем угодно и ни один тест не был бы завален или пропущен из-за неуказанной зависимости.

#### Репозитории пакетов

Если репозиторий содержит файл composer.json в его корневой директории, вы можете оформить его в виде пакета на сайте [Packagist](https://packagist.org/). Это сделает ваш код открытым для всех, кому он потребуется. Если же вы не хотите этого, вы можете поднять свой собственный приватный репозиторий пакетов с использованием [Satis](https://github.com/composer/satis). Это будет полезно при использовании вашего кода в различных ваших проектах или в проектах вашей компании.

После того как composer.json, основанный на том что реально требуется для вашего кода, был создан и зарегистрирован как пакет с использованием Packagist или Satis, вы можете установить этот пакет в любой из ваших проектов, выполнив команду:

```
composer.phar require [name-of-package] 0.1.*
```

Теперь ваш код удовлетворяет второму признаку переносимого кода: после его установки он не будет падать и сбоить из-за отсутствующих зависимостей.

### Жесткая привязка к хранилищу (базе данных)

#### Сущности с автоматическим сопоставлением (auto-mapped)

Одной из самых больших проблем со сторонними бандлами являются сущности (предназначенные для маппинга) с базой данных, которые они определяют (например, с использованием аннотаций) и которые размещаются в директории Entity внутри бандла. Это автоматически делает эти сущности доступными внутри вашего проекта. Это может показаться полезным, но в большинстве ситуаций это не так: в этом случае вы не можете выбрать нужную схему, добавить необходимые вам поля или даже отказать от использования этих сущностей и переопределить модель, например, с использованием документов MongoDB.

Если бандл принуждает к использованию специфичного хранилища, как описано выше, вы узнаете об этом как только выполните команду типа doctrine:schema:update: не спрашивая вашего разрешения, внезапно, будут созданы все таблицы для сущностей из стороннего бандла потому что вы его активировали, и все его сущности были автоматически зарегистрированы в вашем проекте. Та же проблема возникает если выполнить команду doctrine:migrations:diff. В этом случае скрипт миграции будет сгенерирован для таблиц, которые вам возможно и не нужны.

#### Модели, не привязанные к хранилищу

Правильным способом определения моделей ваших бандлов является создание базовых классов. Эти базовые классы должны содержать `get*`, `set*` и прочие методы для модификации или проверки состояния объекта. Они должны иметь защищенные (protected) свойства (по умолчанию свойства объявляются приватными, но в этом случае дочерние классы не будут иметь к ним доступа) и не должны содержать никаких аннотаций для маппинга. Такие модели, не привязанные к хранилищу должны размещаться внутри бандла в директории Model и не должны содержать кода, специфичного для их менеджера моделей (например, для Doctrine это EntityManager или DocumentManager).

```php
namespace Matthias\MessageBundle\Model;

class Message
{
    protected $body;

    public function getBody()
    {
        return $this->body;
    }
}
```

Такой подход даст возможность разработчикам, которые захотят использовать ваш бандл, унаследовать базовый класс и определить любые необходимые метаданные, необходимые для маппинга данных к нужному типу базы данных:

```php
namespace Matthias\ProjectBundle\Entity;

use Matthias\MessageBundle\Model\Message as BaseMessage;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class Message extends BaseMessage
{
    /**
     * @ORM\Column(type="text")
     */
    protected $body;

    // Application specific data:

    /**
     * @ORM\Column(type="integer")
     */
    protected $upVotes;

    /**
     * @ORM\Column(type="integer")
     */
    protected $downVotes;
}
```

Как вы можете видеть, такой подход позволяет добавлять дополнительные поля, которых не было в базовой сущности. Также убедитесь, что ваш бандл имеет настройку для указания пользовательского класса модели:

```php
matthias_message:
    message_class: Matthias\ProjectBundle\Entity\Message
```

> #### Классы моделей являются библиотечным кодом (фактически)
> 
> Как было предложено ранее, вам нужно отделять любой код, который не специфичен для Symfony-приложения в отдельные библиотеки. Тоже применимо и для классов моделей. Они не должны быть частью бандла, а должны быть частью библиотеки.

#### Менеджеры объектов

Даже если вы определили модели не зависящие от хранилища, это не значит, что ваш бандл должен также быть независимым от него. Вы лишь должны позаботиться о том, что пользователи вашего приложения должны иметь возможность реализации собственных методов работы с хранилищем и соответственно возможность отключить стандартный, который реализовали вы. Вы можете воспользоваться [паттерном Стратегия для загрузки сервисов](#strategy_pattern_loading_exclusive_services), а также используя алиасы.

Также вы должны предоставить возможность конфигурирования имен менеджеров сущностей, документов и т.д. Например, DoctrineORM позволяет пользователям определять различные менеджеры для различных классов сущностей. Таким образом даже если менеджер сущностей, используемый по умолчанию, в большинстве случаев будет правильным, вы должны добавить ключ конфигурации для его переопределения в конфигурации вашего бандла.

### Жесткая привязка к файловой системе

Убедитесь, что ваш бандл не содержит жесткой привязки к файловой системе за пределами вашего бандла. Вы можете более-менее быть уверены в том, что все что находится в корневой директории бандла - под вашим контролем, но все что находится вовне - директории vendors, web или любые другие директории - должно считаться неизвестным. Фактически, так и есть: когда речь заходит о структуре директорий, ничто не может быть постоянным при использовании Symfony. Есть только "значения по умолчанию".

Любая ссылка на что-то вне домашней директории бандла должна быть частью конфигурации и следовательно настраиваемой через config.yml. Вы также можете предлагать значения по умолчанию, чтобы ваш бандл мог заработать "из-коробки" при его установке в стандартный Symfony проект. Обычно для подобных настроек используется скалярный нод со значением по умолчанию в дереве конфигурации. Затем эта конфигурация будет обработана в методе load() в классе расширения вашего бандла и будет определен параметр для нее. Позднее этот параметр может быть внедрен, например, в качестве аргумента конструктора. См. также раздел [Определяем параметры в расширениях контейнера](#define_parameters_in_container_extension).

#### Использование файловой системы

Когда вашему бандлу необходимо использовать для хранения данных помимо СУБД что-то еще, например, хранить файлы, загруженные пользователями, постарайтесь сделать бандл независимым от файловой системы. Так как не каждое приложение имеет доступ на запись к файловой системе на сервере, вы можете использовать слой абстракции файловой системы, как например [Gaufrette](https://github.com/KnpLabs/Gaufrette). Эта библиотека имеет адаптеры для различных типов файловых систем (локальных и удаленных), и ваши сервисы даже не будут (и не должны) замечать, когда эти адаптеры переключаются. Также имеется [GaufretteBundle](https://github.com/KnpLabs/KnpGaufretteBundle), который упрощает процесс интеграции этой библиотеки с вашими Symfony бандлами.
